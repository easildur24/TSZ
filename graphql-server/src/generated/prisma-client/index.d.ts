// Code generated by Prisma (prisma@1.25.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  academics: (where?: AcademicsWhereInput) => Promise<boolean>;
  actScores: (where?: ActScoresWhereInput) => Promise<boolean>;
  actScoresTemplate: (where?: ActScoresTemplateWhereInput) => Promise<boolean>;
  admission: (where?: AdmissionWhereInput) => Promise<boolean>;
  badge: (where?: BadgeWhereInput) => Promise<boolean>;
  cost: (where?: CostWhereInput) => Promise<boolean>;
  demographics: (where?: DemographicsWhereInput) => Promise<boolean>;
  geography: (where?: GeographyWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  overview: (where?: OverviewWhereInput) => Promise<boolean>;
  ranking: (where?: RankingWhereInput) => Promise<boolean>;
  satScores: (where?: SatScoresWhereInput) => Promise<boolean>;
  satScoresTemplate: (where?: SatScoresTemplateWhereInput) => Promise<boolean>;
  schoolDetailsItem: (where?: SchoolDetailsItemWhereInput) => Promise<boolean>;
  schoolListItem: (where?: SchoolListItemWhereInput) => Promise<boolean>;
  schoolRecommendation: (
    where?: SchoolRecommendationWhereInput
  ) => Promise<boolean>;
  schoolSuggestion: (where?: SchoolSuggestionWhereInput) => Promise<boolean>;
  college: (where?: collegeWhereInput) => Promise<boolean>;
  major: (where?: majorWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  academicses: (args?: {
    where?: AcademicsWhereInput;
    orderBy?: AcademicsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Academics>;
  academicsesConnection: (args?: {
    where?: AcademicsWhereInput;
    orderBy?: AcademicsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AcademicsConnectionPromise;
  actScoreses: (args?: {
    where?: ActScoresWhereInput;
    orderBy?: ActScoresOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActScores>;
  actScoresesConnection: (args?: {
    where?: ActScoresWhereInput;
    orderBy?: ActScoresOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActScoresConnectionPromise;
  actScoresTemplates: (args?: {
    where?: ActScoresTemplateWhereInput;
    orderBy?: ActScoresTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActScoresTemplate>;
  actScoresTemplatesConnection: (args?: {
    where?: ActScoresTemplateWhereInput;
    orderBy?: ActScoresTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActScoresTemplateConnectionPromise;
  admissions: (args?: {
    where?: AdmissionWhereInput;
    orderBy?: AdmissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Admission>;
  admissionsConnection: (args?: {
    where?: AdmissionWhereInput;
    orderBy?: AdmissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdmissionConnectionPromise;
  badges: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Badge>;
  badgesConnection: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BadgeConnectionPromise;
  costs: (args?: {
    where?: CostWhereInput;
    orderBy?: CostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Cost>;
  costsConnection: (args?: {
    where?: CostWhereInput;
    orderBy?: CostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CostConnectionPromise;
  demographicses: (args?: {
    where?: DemographicsWhereInput;
    orderBy?: DemographicsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Demographics>;
  demographicsesConnection: (args?: {
    where?: DemographicsWhereInput;
    orderBy?: DemographicsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DemographicsConnectionPromise;
  geographies: (args?: {
    where?: GeographyWhereInput;
    orderBy?: GeographyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Geography>;
  geographiesConnection: (args?: {
    where?: GeographyWhereInput;
    orderBy?: GeographyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GeographyConnectionPromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  overviews: (args?: {
    where?: OverviewWhereInput;
    orderBy?: OverviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Overview>;
  overviewsConnection: (args?: {
    where?: OverviewWhereInput;
    orderBy?: OverviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OverviewConnectionPromise;
  rankings: (args?: {
    where?: RankingWhereInput;
    orderBy?: RankingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ranking>;
  rankingsConnection: (args?: {
    where?: RankingWhereInput;
    orderBy?: RankingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RankingConnectionPromise;
  satScoreses: (args?: {
    where?: SatScoresWhereInput;
    orderBy?: SatScoresOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SatScores>;
  satScoresesConnection: (args?: {
    where?: SatScoresWhereInput;
    orderBy?: SatScoresOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SatScoresConnectionPromise;
  satScoresTemplates: (args?: {
    where?: SatScoresTemplateWhereInput;
    orderBy?: SatScoresTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SatScoresTemplate>;
  satScoresTemplatesConnection: (args?: {
    where?: SatScoresTemplateWhereInput;
    orderBy?: SatScoresTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SatScoresTemplateConnectionPromise;
  schoolDetailsItem: (
    where: SchoolDetailsItemWhereUniqueInput
  ) => SchoolDetailsItemPromise;
  schoolDetailsItems: (args?: {
    where?: SchoolDetailsItemWhereInput;
    orderBy?: SchoolDetailsItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SchoolDetailsItem>;
  schoolDetailsItemsConnection: (args?: {
    where?: SchoolDetailsItemWhereInput;
    orderBy?: SchoolDetailsItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SchoolDetailsItemConnectionPromise;
  schoolListItem: (
    where: SchoolListItemWhereUniqueInput
  ) => SchoolListItemPromise;
  schoolListItems: (args?: {
    where?: SchoolListItemWhereInput;
    orderBy?: SchoolListItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SchoolListItem>;
  schoolListItemsConnection: (args?: {
    where?: SchoolListItemWhereInput;
    orderBy?: SchoolListItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SchoolListItemConnectionPromise;
  schoolRecommendations: (args?: {
    where?: SchoolRecommendationWhereInput;
    orderBy?: SchoolRecommendationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SchoolRecommendation>;
  schoolRecommendationsConnection: (args?: {
    where?: SchoolRecommendationWhereInput;
    orderBy?: SchoolRecommendationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SchoolRecommendationConnectionPromise;
  schoolSuggestions: (args?: {
    where?: SchoolSuggestionWhereInput;
    orderBy?: SchoolSuggestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SchoolSuggestion>;
  schoolSuggestionsConnection: (args?: {
    where?: SchoolSuggestionWhereInput;
    orderBy?: SchoolSuggestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SchoolSuggestionConnectionPromise;
  colleges: (args?: {
    where?: collegeWhereInput;
    orderBy?: collegeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<college>;
  collegesConnection: (args?: {
    where?: collegeWhereInput;
    orderBy?: collegeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => collegeConnectionPromise;
  majors: (args?: {
    where?: majorWhereInput;
    orderBy?: majorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<major>;
  majorsConnection: (args?: {
    where?: majorWhereInput;
    orderBy?: majorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => majorConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAcademics: (data: AcademicsCreateInput) => AcademicsPromise;
  deleteManyAcademicses: (where?: AcademicsWhereInput) => BatchPayloadPromise;
  createActScores: (data: ActScoresCreateInput) => ActScoresPromise;
  deleteManyActScoreses: (where?: ActScoresWhereInput) => BatchPayloadPromise;
  createActScoresTemplate: (
    data: ActScoresTemplateCreateInput
  ) => ActScoresTemplatePromise;
  updateManyActScoresTemplates: (args: {
    data: ActScoresTemplateUpdateManyMutationInput;
    where?: ActScoresTemplateWhereInput;
  }) => BatchPayloadPromise;
  deleteManyActScoresTemplates: (
    where?: ActScoresTemplateWhereInput
  ) => BatchPayloadPromise;
  createAdmission: (data: AdmissionCreateInput) => AdmissionPromise;
  updateManyAdmissions: (args: {
    data: AdmissionUpdateManyMutationInput;
    where?: AdmissionWhereInput;
  }) => BatchPayloadPromise;
  deleteManyAdmissions: (where?: AdmissionWhereInput) => BatchPayloadPromise;
  createBadge: (data: BadgeCreateInput) => BadgePromise;
  updateManyBadges: (args: {
    data: BadgeUpdateManyMutationInput;
    where?: BadgeWhereInput;
  }) => BatchPayloadPromise;
  deleteManyBadges: (where?: BadgeWhereInput) => BatchPayloadPromise;
  createCost: (data: CostCreateInput) => CostPromise;
  updateManyCosts: (args: {
    data: CostUpdateManyMutationInput;
    where?: CostWhereInput;
  }) => BatchPayloadPromise;
  deleteManyCosts: (where?: CostWhereInput) => BatchPayloadPromise;
  createDemographics: (data: DemographicsCreateInput) => DemographicsPromise;
  updateManyDemographicses: (args: {
    data: DemographicsUpdateManyMutationInput;
    where?: DemographicsWhereInput;
  }) => BatchPayloadPromise;
  deleteManyDemographicses: (
    where?: DemographicsWhereInput
  ) => BatchPayloadPromise;
  createGeography: (data: GeographyCreateInput) => GeographyPromise;
  deleteManyGeographies: (where?: GeographyWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createOverview: (data: OverviewCreateInput) => OverviewPromise;
  updateManyOverviews: (args: {
    data: OverviewUpdateManyMutationInput;
    where?: OverviewWhereInput;
  }) => BatchPayloadPromise;
  deleteManyOverviews: (where?: OverviewWhereInput) => BatchPayloadPromise;
  createRanking: (data: RankingCreateInput) => RankingPromise;
  updateManyRankings: (args: {
    data: RankingUpdateManyMutationInput;
    where?: RankingWhereInput;
  }) => BatchPayloadPromise;
  deleteManyRankings: (where?: RankingWhereInput) => BatchPayloadPromise;
  createSatScores: (data: SatScoresCreateInput) => SatScoresPromise;
  deleteManySatScoreses: (where?: SatScoresWhereInput) => BatchPayloadPromise;
  createSatScoresTemplate: (
    data: SatScoresTemplateCreateInput
  ) => SatScoresTemplatePromise;
  updateManySatScoresTemplates: (args: {
    data: SatScoresTemplateUpdateManyMutationInput;
    where?: SatScoresTemplateWhereInput;
  }) => BatchPayloadPromise;
  deleteManySatScoresTemplates: (
    where?: SatScoresTemplateWhereInput
  ) => BatchPayloadPromise;
  createSchoolDetailsItem: (
    data: SchoolDetailsItemCreateInput
  ) => SchoolDetailsItemPromise;
  updateSchoolDetailsItem: (args: {
    data: SchoolDetailsItemUpdateInput;
    where: SchoolDetailsItemWhereUniqueInput;
  }) => SchoolDetailsItemPromise;
  updateManySchoolDetailsItems: (args: {
    data: SchoolDetailsItemUpdateManyMutationInput;
    where?: SchoolDetailsItemWhereInput;
  }) => BatchPayloadPromise;
  upsertSchoolDetailsItem: (args: {
    where: SchoolDetailsItemWhereUniqueInput;
    create: SchoolDetailsItemCreateInput;
    update: SchoolDetailsItemUpdateInput;
  }) => SchoolDetailsItemPromise;
  deleteSchoolDetailsItem: (
    where: SchoolDetailsItemWhereUniqueInput
  ) => SchoolDetailsItemPromise;
  deleteManySchoolDetailsItems: (
    where?: SchoolDetailsItemWhereInput
  ) => BatchPayloadPromise;
  createSchoolListItem: (
    data: SchoolListItemCreateInput
  ) => SchoolListItemPromise;
  updateSchoolListItem: (args: {
    data: SchoolListItemUpdateInput;
    where: SchoolListItemWhereUniqueInput;
  }) => SchoolListItemPromise;
  updateManySchoolListItems: (args: {
    data: SchoolListItemUpdateManyMutationInput;
    where?: SchoolListItemWhereInput;
  }) => BatchPayloadPromise;
  upsertSchoolListItem: (args: {
    where: SchoolListItemWhereUniqueInput;
    create: SchoolListItemCreateInput;
    update: SchoolListItemUpdateInput;
  }) => SchoolListItemPromise;
  deleteSchoolListItem: (
    where: SchoolListItemWhereUniqueInput
  ) => SchoolListItemPromise;
  deleteManySchoolListItems: (
    where?: SchoolListItemWhereInput
  ) => BatchPayloadPromise;
  createSchoolRecommendation: (
    data: SchoolRecommendationCreateInput
  ) => SchoolRecommendationPromise;
  updateManySchoolRecommendations: (args: {
    data: SchoolRecommendationUpdateManyMutationInput;
    where?: SchoolRecommendationWhereInput;
  }) => BatchPayloadPromise;
  deleteManySchoolRecommendations: (
    where?: SchoolRecommendationWhereInput
  ) => BatchPayloadPromise;
  createSchoolSuggestion: (
    data: SchoolSuggestionCreateInput
  ) => SchoolSuggestionPromise;
  updateManySchoolSuggestions: (args: {
    data: SchoolSuggestionUpdateManyMutationInput;
    where?: SchoolSuggestionWhereInput;
  }) => BatchPayloadPromise;
  deleteManySchoolSuggestions: (
    where?: SchoolSuggestionWhereInput
  ) => BatchPayloadPromise;
  createcollege: (data: collegeCreateInput) => collegePromise;
  updateManycolleges: (args: {
    data: collegeUpdateManyMutationInput;
    where?: collegeWhereInput;
  }) => BatchPayloadPromise;
  deleteManycolleges: (where?: collegeWhereInput) => BatchPayloadPromise;
  createmajor: (data: majorCreateInput) => majorPromise;
  updateManymajors: (args: {
    data: majorUpdateManyMutationInput;
    where?: majorWhereInput;
  }) => BatchPayloadPromise;
  deleteManymajors: (where?: majorWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  academics: (
    where?: AcademicsSubscriptionWhereInput
  ) => AcademicsSubscriptionPayloadSubscription;
  actScores: (
    where?: ActScoresSubscriptionWhereInput
  ) => ActScoresSubscriptionPayloadSubscription;
  actScoresTemplate: (
    where?: ActScoresTemplateSubscriptionWhereInput
  ) => ActScoresTemplateSubscriptionPayloadSubscription;
  admission: (
    where?: AdmissionSubscriptionWhereInput
  ) => AdmissionSubscriptionPayloadSubscription;
  badge: (
    where?: BadgeSubscriptionWhereInput
  ) => BadgeSubscriptionPayloadSubscription;
  cost: (
    where?: CostSubscriptionWhereInput
  ) => CostSubscriptionPayloadSubscription;
  demographics: (
    where?: DemographicsSubscriptionWhereInput
  ) => DemographicsSubscriptionPayloadSubscription;
  geography: (
    where?: GeographySubscriptionWhereInput
  ) => GeographySubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  overview: (
    where?: OverviewSubscriptionWhereInput
  ) => OverviewSubscriptionPayloadSubscription;
  ranking: (
    where?: RankingSubscriptionWhereInput
  ) => RankingSubscriptionPayloadSubscription;
  satScores: (
    where?: SatScoresSubscriptionWhereInput
  ) => SatScoresSubscriptionPayloadSubscription;
  satScoresTemplate: (
    where?: SatScoresTemplateSubscriptionWhereInput
  ) => SatScoresTemplateSubscriptionPayloadSubscription;
  schoolDetailsItem: (
    where?: SchoolDetailsItemSubscriptionWhereInput
  ) => SchoolDetailsItemSubscriptionPayloadSubscription;
  schoolListItem: (
    where?: SchoolListItemSubscriptionWhereInput
  ) => SchoolListItemSubscriptionPayloadSubscription;
  schoolRecommendation: (
    where?: SchoolRecommendationSubscriptionWhereInput
  ) => SchoolRecommendationSubscriptionPayloadSubscription;
  schoolSuggestion: (
    where?: SchoolSuggestionSubscriptionWhereInput
  ) => SchoolSuggestionSubscriptionPayloadSubscription;
  college: (
    where?: collegeSubscriptionWhereInput
  ) => collegeSubscriptionPayloadSubscription;
  major: (
    where?: majorSubscriptionWhereInput
  ) => majorSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AcademicsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type majorOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type collegeOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActScoresOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActScoresTemplateOrderByInput =
  | "writing_ASC"
  | "writing_DESC"
  | "english_ASC"
  | "english_DESC"
  | "math_ASC"
  | "math_DESC"
  | "cumulative_ASC"
  | "cumulative_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AdmissionOrderByInput =
  | "acceptanceRate_ASC"
  | "acceptanceRate_DESC"
  | "toeflMinScore_ASC"
  | "toeflMinScore_DESC"
  | "ieltsMinScore_ASC"
  | "ieltsMinScore_DESC"
  | "earlyDecisionDeadline_ASC"
  | "earlyDecisionDeadline_DESC"
  | "regularDeadline_ASC"
  | "regularDeadline_DESC"
  | "schoolResponseDeadline_ASC"
  | "schoolResponseDeadline_DESC"
  | "studentResponseDeadline_ASC"
  | "studentResponseDeadline_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BadgeOrderByInput =
  | "tooltip_ASC"
  | "tooltip_DESC"
  | "url_ASC"
  | "url_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CostOrderByInput =
  | "tuitionUndergrad_ASC"
  | "tuitionUndergrad_DESC"
  | "tuitionGrad_ASC"
  | "tuitionGrad_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DemographicsOrderByInput =
  | "numStudents_ASC"
  | "numStudents_DESC"
  | "numUndergraduates_ASC"
  | "numUndergraduates_DESC"
  | "numGraduates_ASC"
  | "numGraduates_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GeographyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "latittude_ASC"
  | "latittude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "state_ASC"
  | "state_DESC"
  | "city_ASC"
  | "city_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type System = "SEMESTER" | "QUARTER";

export type OverviewOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "url_ASC"
  | "url_DESC"
  | "menOnly_ASC"
  | "menOnly_DESC"
  | "womenOnly_ASC"
  | "womenOnly_DESC"
  | "operating_ASC"
  | "operating_DESC"
  | "onlineOnly_ASC"
  | "onlineOnly_DESC"
  | "deadline_ASC"
  | "deadline_DESC"
  | "system_ASC"
  | "system_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RankingOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SatScoresOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SatScoresTemplateOrderByInput =
  | "reading_ASC"
  | "reading_DESC"
  | "writing_ASC"
  | "writing_DESC"
  | "math_ASC"
  | "math_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SchoolDetailsItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SchoolListItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "acceptanceRate_ASC"
  | "acceptanceRate_DESC"
  | "toeflMinScore_ASC"
  | "toeflMinScore_DESC"
  | "regularDeadline_ASC"
  | "regularDeadline_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SchoolRecommendationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SchoolSuggestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface AcademicsWhereInput {
  majors_every?: majorWhereInput;
  majors_some?: majorWhereInput;
  majors_none?: majorWhereInput;
  colleges_every?: collegeWhereInput;
  colleges_some?: collegeWhereInput;
  colleges_none?: collegeWhereInput;
  AND?: AcademicsWhereInput[] | AcademicsWhereInput;
  OR?: AcademicsWhereInput[] | AcademicsWhereInput;
  NOT?: AcademicsWhereInput[] | AcademicsWhereInput;
}

export interface majorWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  AND?: majorWhereInput[] | majorWhereInput;
  OR?: majorWhereInput[] | majorWhereInput;
  NOT?: majorWhereInput[] | majorWhereInput;
}

export interface collegeWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  AND?: collegeWhereInput[] | collegeWhereInput;
  OR?: collegeWhereInput[] | collegeWhereInput;
  NOT?: collegeWhereInput[] | collegeWhereInput;
}

export interface ActScoresWhereInput {
  percentile25th?: ActScoresTemplateWhereInput;
  mid?: ActScoresTemplateWhereInput;
  percentile75th?: ActScoresTemplateWhereInput;
  AND?: ActScoresWhereInput[] | ActScoresWhereInput;
  OR?: ActScoresWhereInput[] | ActScoresWhereInput;
  NOT?: ActScoresWhereInput[] | ActScoresWhereInput;
}

export interface ActScoresTemplateWhereInput {
  writing?: Int;
  writing_not?: Int;
  writing_in?: Int[] | Int;
  writing_not_in?: Int[] | Int;
  writing_lt?: Int;
  writing_lte?: Int;
  writing_gt?: Int;
  writing_gte?: Int;
  english?: Int;
  english_not?: Int;
  english_in?: Int[] | Int;
  english_not_in?: Int[] | Int;
  english_lt?: Int;
  english_lte?: Int;
  english_gt?: Int;
  english_gte?: Int;
  math?: Int;
  math_not?: Int;
  math_in?: Int[] | Int;
  math_not_in?: Int[] | Int;
  math_lt?: Int;
  math_lte?: Int;
  math_gt?: Int;
  math_gte?: Int;
  cumulative?: Int;
  cumulative_not?: Int;
  cumulative_in?: Int[] | Int;
  cumulative_not_in?: Int[] | Int;
  cumulative_lt?: Int;
  cumulative_lte?: Int;
  cumulative_gt?: Int;
  cumulative_gte?: Int;
  AND?: ActScoresTemplateWhereInput[] | ActScoresTemplateWhereInput;
  OR?: ActScoresTemplateWhereInput[] | ActScoresTemplateWhereInput;
  NOT?: ActScoresTemplateWhereInput[] | ActScoresTemplateWhereInput;
}

export interface AdmissionWhereInput {
  acceptanceRate?: Float;
  acceptanceRate_not?: Float;
  acceptanceRate_in?: Float[] | Float;
  acceptanceRate_not_in?: Float[] | Float;
  acceptanceRate_lt?: Float;
  acceptanceRate_lte?: Float;
  acceptanceRate_gt?: Float;
  acceptanceRate_gte?: Float;
  actScores?: ActScoresWhereInput;
  satScores?: SatScoresWhereInput;
  toeflMinScore?: Int;
  toeflMinScore_not?: Int;
  toeflMinScore_in?: Int[] | Int;
  toeflMinScore_not_in?: Int[] | Int;
  toeflMinScore_lt?: Int;
  toeflMinScore_lte?: Int;
  toeflMinScore_gt?: Int;
  toeflMinScore_gte?: Int;
  ieltsMinScore?: Int;
  ieltsMinScore_not?: Int;
  ieltsMinScore_in?: Int[] | Int;
  ieltsMinScore_not_in?: Int[] | Int;
  ieltsMinScore_lt?: Int;
  ieltsMinScore_lte?: Int;
  ieltsMinScore_gt?: Int;
  ieltsMinScore_gte?: Int;
  earlyDecisionDeadline?: DateTimeInput;
  earlyDecisionDeadline_not?: DateTimeInput;
  earlyDecisionDeadline_in?: DateTimeInput[] | DateTimeInput;
  earlyDecisionDeadline_not_in?: DateTimeInput[] | DateTimeInput;
  earlyDecisionDeadline_lt?: DateTimeInput;
  earlyDecisionDeadline_lte?: DateTimeInput;
  earlyDecisionDeadline_gt?: DateTimeInput;
  earlyDecisionDeadline_gte?: DateTimeInput;
  regularDeadline?: DateTimeInput;
  regularDeadline_not?: DateTimeInput;
  regularDeadline_in?: DateTimeInput[] | DateTimeInput;
  regularDeadline_not_in?: DateTimeInput[] | DateTimeInput;
  regularDeadline_lt?: DateTimeInput;
  regularDeadline_lte?: DateTimeInput;
  regularDeadline_gt?: DateTimeInput;
  regularDeadline_gte?: DateTimeInput;
  schoolResponseDeadline?: DateTimeInput;
  schoolResponseDeadline_not?: DateTimeInput;
  schoolResponseDeadline_in?: DateTimeInput[] | DateTimeInput;
  schoolResponseDeadline_not_in?: DateTimeInput[] | DateTimeInput;
  schoolResponseDeadline_lt?: DateTimeInput;
  schoolResponseDeadline_lte?: DateTimeInput;
  schoolResponseDeadline_gt?: DateTimeInput;
  schoolResponseDeadline_gte?: DateTimeInput;
  studentResponseDeadline?: DateTimeInput;
  studentResponseDeadline_not?: DateTimeInput;
  studentResponseDeadline_in?: DateTimeInput[] | DateTimeInput;
  studentResponseDeadline_not_in?: DateTimeInput[] | DateTimeInput;
  studentResponseDeadline_lt?: DateTimeInput;
  studentResponseDeadline_lte?: DateTimeInput;
  studentResponseDeadline_gt?: DateTimeInput;
  studentResponseDeadline_gte?: DateTimeInput;
  AND?: AdmissionWhereInput[] | AdmissionWhereInput;
  OR?: AdmissionWhereInput[] | AdmissionWhereInput;
  NOT?: AdmissionWhereInput[] | AdmissionWhereInput;
}

export interface SatScoresWhereInput {
  percentile25th?: SatScoresTemplateWhereInput;
  mid?: SatScoresTemplateWhereInput;
  percentile75th?: SatScoresTemplateWhereInput;
  AND?: SatScoresWhereInput[] | SatScoresWhereInput;
  OR?: SatScoresWhereInput[] | SatScoresWhereInput;
  NOT?: SatScoresWhereInput[] | SatScoresWhereInput;
}

export interface SatScoresTemplateWhereInput {
  reading?: Int;
  reading_not?: Int;
  reading_in?: Int[] | Int;
  reading_not_in?: Int[] | Int;
  reading_lt?: Int;
  reading_lte?: Int;
  reading_gt?: Int;
  reading_gte?: Int;
  writing?: Int;
  writing_not?: Int;
  writing_in?: Int[] | Int;
  writing_not_in?: Int[] | Int;
  writing_lt?: Int;
  writing_lte?: Int;
  writing_gt?: Int;
  writing_gte?: Int;
  math?: Int;
  math_not?: Int;
  math_in?: Int[] | Int;
  math_not_in?: Int[] | Int;
  math_lt?: Int;
  math_lte?: Int;
  math_gt?: Int;
  math_gte?: Int;
  AND?: SatScoresTemplateWhereInput[] | SatScoresTemplateWhereInput;
  OR?: SatScoresTemplateWhereInput[] | SatScoresTemplateWhereInput;
  NOT?: SatScoresTemplateWhereInput[] | SatScoresTemplateWhereInput;
}

export interface BadgeWhereInput {
  tooltip?: String;
  tooltip_not?: String;
  tooltip_in?: String[] | String;
  tooltip_not_in?: String[] | String;
  tooltip_lt?: String;
  tooltip_lte?: String;
  tooltip_gt?: String;
  tooltip_gte?: String;
  tooltip_contains?: String;
  tooltip_not_contains?: String;
  tooltip_starts_with?: String;
  tooltip_not_starts_with?: String;
  tooltip_ends_with?: String;
  tooltip_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: BadgeWhereInput[] | BadgeWhereInput;
  OR?: BadgeWhereInput[] | BadgeWhereInput;
  NOT?: BadgeWhereInput[] | BadgeWhereInput;
}

export interface CostWhereInput {
  tuitionUndergrad?: Int;
  tuitionUndergrad_not?: Int;
  tuitionUndergrad_in?: Int[] | Int;
  tuitionUndergrad_not_in?: Int[] | Int;
  tuitionUndergrad_lt?: Int;
  tuitionUndergrad_lte?: Int;
  tuitionUndergrad_gt?: Int;
  tuitionUndergrad_gte?: Int;
  tuitionGrad?: Int;
  tuitionGrad_not?: Int;
  tuitionGrad_in?: Int[] | Int;
  tuitionGrad_not_in?: Int[] | Int;
  tuitionGrad_lt?: Int;
  tuitionGrad_lte?: Int;
  tuitionGrad_gt?: Int;
  tuitionGrad_gte?: Int;
  AND?: CostWhereInput[] | CostWhereInput;
  OR?: CostWhereInput[] | CostWhereInput;
  NOT?: CostWhereInput[] | CostWhereInput;
}

export interface DemographicsWhereInput {
  numStudents?: Int;
  numStudents_not?: Int;
  numStudents_in?: Int[] | Int;
  numStudents_not_in?: Int[] | Int;
  numStudents_lt?: Int;
  numStudents_lte?: Int;
  numStudents_gt?: Int;
  numStudents_gte?: Int;
  numUndergraduates?: Int;
  numUndergraduates_not?: Int;
  numUndergraduates_in?: Int[] | Int;
  numUndergraduates_not_in?: Int[] | Int;
  numUndergraduates_lt?: Int;
  numUndergraduates_lte?: Int;
  numUndergraduates_gt?: Int;
  numUndergraduates_gte?: Int;
  numGraduates?: Int;
  numGraduates_not?: Int;
  numGraduates_in?: Int[] | Int;
  numGraduates_not_in?: Int[] | Int;
  numGraduates_lt?: Int;
  numGraduates_lte?: Int;
  numGraduates_gt?: Int;
  numGraduates_gte?: Int;
  AND?: DemographicsWhereInput[] | DemographicsWhereInput;
  OR?: DemographicsWhereInput[] | DemographicsWhereInput;
  NOT?: DemographicsWhereInput[] | DemographicsWhereInput;
}

export interface GeographyWhereInput {
  location?: LocationWhereInput;
  AND?: GeographyWhereInput[] | GeographyWhereInput;
  OR?: GeographyWhereInput[] | GeographyWhereInput;
  NOT?: GeographyWhereInput[] | GeographyWhereInput;
}

export interface LocationWhereInput {
  latittude?: Float;
  latittude_not?: Float;
  latittude_in?: Float[] | Float;
  latittude_not_in?: Float[] | Float;
  latittude_lt?: Float;
  latittude_lte?: Float;
  latittude_gt?: Float;
  latittude_gte?: Float;
  longitude?: Float;
  longitude_not?: Float;
  longitude_in?: Float[] | Float;
  longitude_not_in?: Float[] | Float;
  longitude_lt?: Float;
  longitude_lte?: Float;
  longitude_gt?: Float;
  longitude_gte?: Float;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  zip?: String;
  zip_not?: String;
  zip_in?: String[] | String;
  zip_not_in?: String[] | String;
  zip_lt?: String;
  zip_lte?: String;
  zip_gt?: String;
  zip_gte?: String;
  zip_contains?: String;
  zip_not_contains?: String;
  zip_starts_with?: String;
  zip_not_starts_with?: String;
  zip_ends_with?: String;
  zip_not_ends_with?: String;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface OverviewWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  notableRankings_every?: RankingWhereInput;
  notableRankings_some?: RankingWhereInput;
  notableRankings_none?: RankingWhereInput;
  badges_every?: BadgeWhereInput;
  badges_some?: BadgeWhereInput;
  badges_none?: BadgeWhereInput;
  location?: LocationWhereInput;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  menOnly?: Boolean;
  menOnly_not?: Boolean;
  womenOnly?: Boolean;
  womenOnly_not?: Boolean;
  operating?: Boolean;
  operating_not?: Boolean;
  onlineOnly?: Boolean;
  onlineOnly_not?: Boolean;
  deadline?: DateTimeInput;
  deadline_not?: DateTimeInput;
  deadline_in?: DateTimeInput[] | DateTimeInput;
  deadline_not_in?: DateTimeInput[] | DateTimeInput;
  deadline_lt?: DateTimeInput;
  deadline_lte?: DateTimeInput;
  deadline_gt?: DateTimeInput;
  deadline_gte?: DateTimeInput;
  system?: System;
  system_not?: System;
  system_in?: System[] | System;
  system_not_in?: System[] | System;
  AND?: OverviewWhereInput[] | OverviewWhereInput;
  OR?: OverviewWhereInput[] | OverviewWhereInput;
  NOT?: OverviewWhereInput[] | OverviewWhereInput;
}

export interface RankingWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  AND?: RankingWhereInput[] | RankingWhereInput;
  OR?: RankingWhereInput[] | RankingWhereInput;
  NOT?: RankingWhereInput[] | RankingWhereInput;
}

export type SchoolDetailsItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolDetailsItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  overview?: OverviewWhereInput;
  admission?: AdmissionWhereInput;
  academics?: AcademicsWhereInput;
  cost?: CostWhereInput;
  demographics?: DemographicsWhereInput;
  geography?: GeographyWhereInput;
  AND?: SchoolDetailsItemWhereInput[] | SchoolDetailsItemWhereInput;
  OR?: SchoolDetailsItemWhereInput[] | SchoolDetailsItemWhereInput;
  NOT?: SchoolDetailsItemWhereInput[] | SchoolDetailsItemWhereInput;
}

export type SchoolListItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolListItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  usRanking?: RankingWhereInput;
  badges_every?: BadgeWhereInput;
  badges_some?: BadgeWhereInput;
  badges_none?: BadgeWhereInput;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  acceptanceRate?: Float;
  acceptanceRate_not?: Float;
  acceptanceRate_in?: Float[] | Float;
  acceptanceRate_not_in?: Float[] | Float;
  acceptanceRate_lt?: Float;
  acceptanceRate_lte?: Float;
  acceptanceRate_gt?: Float;
  acceptanceRate_gte?: Float;
  actScores?: ActScoresWhereInput;
  satScores?: SatScoresWhereInput;
  toeflMinScore?: Int;
  toeflMinScore_not?: Int;
  toeflMinScore_in?: Int[] | Int;
  toeflMinScore_not_in?: Int[] | Int;
  toeflMinScore_lt?: Int;
  toeflMinScore_lte?: Int;
  toeflMinScore_gt?: Int;
  toeflMinScore_gte?: Int;
  regularDeadline?: DateTimeInput;
  regularDeadline_not?: DateTimeInput;
  regularDeadline_in?: DateTimeInput[] | DateTimeInput;
  regularDeadline_not_in?: DateTimeInput[] | DateTimeInput;
  regularDeadline_lt?: DateTimeInput;
  regularDeadline_lte?: DateTimeInput;
  regularDeadline_gt?: DateTimeInput;
  regularDeadline_gte?: DateTimeInput;
  AND?: SchoolListItemWhereInput[] | SchoolListItemWhereInput;
  OR?: SchoolListItemWhereInput[] | SchoolListItemWhereInput;
  NOT?: SchoolListItemWhereInput[] | SchoolListItemWhereInput;
}

export interface SchoolRecommendationWhereInput {
  AND?: SchoolRecommendationWhereInput[] | SchoolRecommendationWhereInput;
  OR?: SchoolRecommendationWhereInput[] | SchoolRecommendationWhereInput;
  NOT?: SchoolRecommendationWhereInput[] | SchoolRecommendationWhereInput;
}

export interface SchoolSuggestionWhereInput {
  AND?: SchoolSuggestionWhereInput[] | SchoolSuggestionWhereInput;
  OR?: SchoolSuggestionWhereInput[] | SchoolSuggestionWhereInput;
  NOT?: SchoolSuggestionWhereInput[] | SchoolSuggestionWhereInput;
}

export interface AcademicsCreateInput {
  majors?: majorCreateManyInput;
  colleges?: collegeCreateManyInput;
}

export interface majorCreateManyInput {
  create?: majorCreateInput[] | majorCreateInput;
}

export interface majorCreateInput {
  name?: String;
  rank?: Int;
}

export interface collegeCreateManyInput {
  create?: collegeCreateInput[] | collegeCreateInput;
}

export interface collegeCreateInput {
  name?: String;
  rank?: Int;
}

export interface ActScoresCreateInput {
  percentile25th?: ActScoresTemplateCreateOneInput;
  mid?: ActScoresTemplateCreateOneInput;
  percentile75th?: ActScoresTemplateCreateOneInput;
}

export interface ActScoresTemplateCreateOneInput {
  create?: ActScoresTemplateCreateInput;
}

export interface ActScoresTemplateCreateInput {
  writing?: Int;
  english?: Int;
  math?: Int;
  cumulative?: Int;
}

export interface ActScoresTemplateUpdateManyMutationInput {
  writing?: Int;
  english?: Int;
  math?: Int;
  cumulative?: Int;
}

export interface AdmissionCreateInput {
  acceptanceRate?: Float;
  actScores?: ActScoresCreateOneInput;
  satScores?: SatScoresCreateOneInput;
  toeflMinScore?: Int;
  ieltsMinScore?: Int;
  earlyDecisionDeadline?: DateTimeInput;
  regularDeadline?: DateTimeInput;
  schoolResponseDeadline?: DateTimeInput;
  studentResponseDeadline?: DateTimeInput;
}

export interface ActScoresCreateOneInput {
  create?: ActScoresCreateInput;
}

export interface SatScoresCreateOneInput {
  create?: SatScoresCreateInput;
}

export interface SatScoresCreateInput {
  percentile25th?: SatScoresTemplateCreateOneInput;
  mid?: SatScoresTemplateCreateOneInput;
  percentile75th?: SatScoresTemplateCreateOneInput;
}

export interface SatScoresTemplateCreateOneInput {
  create?: SatScoresTemplateCreateInput;
}

export interface SatScoresTemplateCreateInput {
  reading?: Int;
  writing?: Int;
  math?: Int;
}

export interface AdmissionUpdateManyMutationInput {
  acceptanceRate?: Float;
  toeflMinScore?: Int;
  ieltsMinScore?: Int;
  earlyDecisionDeadline?: DateTimeInput;
  regularDeadline?: DateTimeInput;
  schoolResponseDeadline?: DateTimeInput;
  studentResponseDeadline?: DateTimeInput;
}

export interface BadgeCreateInput {
  tooltip?: String;
  url?: String;
}

export interface BadgeUpdateManyMutationInput {
  tooltip?: String;
  url?: String;
}

export interface CostCreateInput {
  tuitionUndergrad?: Int;
  tuitionGrad?: Int;
}

export interface CostUpdateManyMutationInput {
  tuitionUndergrad?: Int;
  tuitionGrad?: Int;
}

export interface DemographicsCreateInput {
  numStudents?: Int;
  numUndergraduates?: Int;
  numGraduates?: Int;
}

export interface DemographicsUpdateManyMutationInput {
  numStudents?: Int;
  numUndergraduates?: Int;
  numGraduates?: Int;
}

export interface GeographyCreateInput {
  location?: LocationCreateOneInput;
}

export interface LocationCreateOneInput {
  create?: LocationCreateInput;
}

export interface LocationCreateInput {
  latittude?: Float;
  longitude?: Float;
  state?: String;
  city?: String;
  zip?: String;
}

export interface LocationUpdateManyMutationInput {
  latittude?: Float;
  longitude?: Float;
  state?: String;
  city?: String;
  zip?: String;
}

export interface OverviewCreateInput {
  name: String;
  description?: String;
  notableRankings?: RankingCreateManyInput;
  badges?: BadgeCreateManyInput;
  location?: LocationCreateOneInput;
  url?: String;
  menOnly?: Boolean;
  womenOnly?: Boolean;
  operating?: Boolean;
  onlineOnly?: Boolean;
  deadline?: DateTimeInput;
  system?: System;
}

export interface RankingCreateManyInput {
  create?: RankingCreateInput[] | RankingCreateInput;
}

export interface RankingCreateInput {
  name?: String;
  rank?: Int;
}

export interface BadgeCreateManyInput {
  create?: BadgeCreateInput[] | BadgeCreateInput;
}

export interface OverviewUpdateManyMutationInput {
  name?: String;
  description?: String;
  url?: String;
  menOnly?: Boolean;
  womenOnly?: Boolean;
  operating?: Boolean;
  onlineOnly?: Boolean;
  deadline?: DateTimeInput;
  system?: System;
}

export interface RankingUpdateManyMutationInput {
  name?: String;
  rank?: Int;
}

export interface SatScoresTemplateUpdateManyMutationInput {
  reading?: Int;
  writing?: Int;
  math?: Int;
}

export interface SchoolDetailsItemCreateInput {
  overview?: OverviewCreateOneInput;
  images?: SchoolDetailsItemCreateimagesInput;
  admission?: AdmissionCreateOneInput;
  academics?: AcademicsCreateOneInput;
  cost?: CostCreateOneInput;
  demographics?: DemographicsCreateOneInput;
  geography?: GeographyCreateOneInput;
}

export interface OverviewCreateOneInput {
  create?: OverviewCreateInput;
}

export interface SchoolDetailsItemCreateimagesInput {
  set?: String[] | String;
}

export interface AdmissionCreateOneInput {
  create?: AdmissionCreateInput;
}

export interface AcademicsCreateOneInput {
  create?: AcademicsCreateInput;
}

export interface CostCreateOneInput {
  create?: CostCreateInput;
}

export interface DemographicsCreateOneInput {
  create?: DemographicsCreateInput;
}

export interface GeographyCreateOneInput {
  create?: GeographyCreateInput;
}

export interface SchoolDetailsItemUpdateInput {
  overview?: OverviewUpdateOneInput;
  images?: SchoolDetailsItemUpdateimagesInput;
  admission?: AdmissionUpdateOneInput;
  academics?: AcademicsUpdateOneInput;
  cost?: CostUpdateOneInput;
  demographics?: DemographicsUpdateOneInput;
  geography?: GeographyUpdateOneInput;
}

export interface OverviewUpdateOneInput {
  create?: OverviewCreateInput;
  update?: OverviewUpdateDataInput;
  upsert?: OverviewUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface OverviewUpdateDataInput {
  name?: String;
  description?: String;
  notableRankings?: RankingUpdateManyInput;
  badges?: BadgeUpdateManyInput;
  location?: LocationUpdateOneInput;
  url?: String;
  menOnly?: Boolean;
  womenOnly?: Boolean;
  operating?: Boolean;
  onlineOnly?: Boolean;
  deadline?: DateTimeInput;
  system?: System;
}

export interface RankingUpdateManyInput {
  create?: RankingCreateInput[] | RankingCreateInput;
  deleteMany?: RankingScalarWhereInput[] | RankingScalarWhereInput;
  updateMany?:
    | RankingUpdateManyWithWhereNestedInput[]
    | RankingUpdateManyWithWhereNestedInput;
}

export interface RankingScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  AND?: RankingScalarWhereInput[] | RankingScalarWhereInput;
  OR?: RankingScalarWhereInput[] | RankingScalarWhereInput;
  NOT?: RankingScalarWhereInput[] | RankingScalarWhereInput;
}

export interface RankingUpdateManyWithWhereNestedInput {
  where: RankingScalarWhereInput;
  data: RankingUpdateManyDataInput;
}

export interface RankingUpdateManyDataInput {
  name?: String;
  rank?: Int;
}

export interface BadgeUpdateManyInput {
  create?: BadgeCreateInput[] | BadgeCreateInput;
  deleteMany?: BadgeScalarWhereInput[] | BadgeScalarWhereInput;
  updateMany?:
    | BadgeUpdateManyWithWhereNestedInput[]
    | BadgeUpdateManyWithWhereNestedInput;
}

export interface BadgeScalarWhereInput {
  tooltip?: String;
  tooltip_not?: String;
  tooltip_in?: String[] | String;
  tooltip_not_in?: String[] | String;
  tooltip_lt?: String;
  tooltip_lte?: String;
  tooltip_gt?: String;
  tooltip_gte?: String;
  tooltip_contains?: String;
  tooltip_not_contains?: String;
  tooltip_starts_with?: String;
  tooltip_not_starts_with?: String;
  tooltip_ends_with?: String;
  tooltip_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: BadgeScalarWhereInput[] | BadgeScalarWhereInput;
  OR?: BadgeScalarWhereInput[] | BadgeScalarWhereInput;
  NOT?: BadgeScalarWhereInput[] | BadgeScalarWhereInput;
}

export interface BadgeUpdateManyWithWhereNestedInput {
  where: BadgeScalarWhereInput;
  data: BadgeUpdateManyDataInput;
}

export interface BadgeUpdateManyDataInput {
  tooltip?: String;
  url?: String;
}

export interface LocationUpdateOneInput {
  create?: LocationCreateInput;
  update?: LocationUpdateDataInput;
  upsert?: LocationUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface LocationUpdateDataInput {
  latittude?: Float;
  longitude?: Float;
  state?: String;
  city?: String;
  zip?: String;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface OverviewUpsertNestedInput {
  update: OverviewUpdateDataInput;
  create: OverviewCreateInput;
}

export interface SchoolDetailsItemUpdateimagesInput {
  set?: String[] | String;
}

export interface AdmissionUpdateOneInput {
  create?: AdmissionCreateInput;
  update?: AdmissionUpdateDataInput;
  upsert?: AdmissionUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface AdmissionUpdateDataInput {
  acceptanceRate?: Float;
  actScores?: ActScoresUpdateOneInput;
  satScores?: SatScoresUpdateOneInput;
  toeflMinScore?: Int;
  ieltsMinScore?: Int;
  earlyDecisionDeadline?: DateTimeInput;
  regularDeadline?: DateTimeInput;
  schoolResponseDeadline?: DateTimeInput;
  studentResponseDeadline?: DateTimeInput;
}

export interface ActScoresUpdateOneInput {
  create?: ActScoresCreateInput;
  update?: ActScoresUpdateDataInput;
  upsert?: ActScoresUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface ActScoresUpdateDataInput {
  percentile25th?: ActScoresTemplateUpdateOneInput;
  mid?: ActScoresTemplateUpdateOneInput;
  percentile75th?: ActScoresTemplateUpdateOneInput;
}

export interface ActScoresTemplateUpdateOneInput {
  create?: ActScoresTemplateCreateInput;
  update?: ActScoresTemplateUpdateDataInput;
  upsert?: ActScoresTemplateUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface ActScoresTemplateUpdateDataInput {
  writing?: Int;
  english?: Int;
  math?: Int;
  cumulative?: Int;
}

export interface ActScoresTemplateUpsertNestedInput {
  update: ActScoresTemplateUpdateDataInput;
  create: ActScoresTemplateCreateInput;
}

export interface ActScoresUpsertNestedInput {
  update: ActScoresUpdateDataInput;
  create: ActScoresCreateInput;
}

export interface SatScoresUpdateOneInput {
  create?: SatScoresCreateInput;
  update?: SatScoresUpdateDataInput;
  upsert?: SatScoresUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface SatScoresUpdateDataInput {
  percentile25th?: SatScoresTemplateUpdateOneInput;
  mid?: SatScoresTemplateUpdateOneInput;
  percentile75th?: SatScoresTemplateUpdateOneInput;
}

export interface SatScoresTemplateUpdateOneInput {
  create?: SatScoresTemplateCreateInput;
  update?: SatScoresTemplateUpdateDataInput;
  upsert?: SatScoresTemplateUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface SatScoresTemplateUpdateDataInput {
  reading?: Int;
  writing?: Int;
  math?: Int;
}

export interface SatScoresTemplateUpsertNestedInput {
  update: SatScoresTemplateUpdateDataInput;
  create: SatScoresTemplateCreateInput;
}

export interface SatScoresUpsertNestedInput {
  update: SatScoresUpdateDataInput;
  create: SatScoresCreateInput;
}

export interface AdmissionUpsertNestedInput {
  update: AdmissionUpdateDataInput;
  create: AdmissionCreateInput;
}

export interface AcademicsUpdateOneInput {
  create?: AcademicsCreateInput;
  update?: AcademicsUpdateDataInput;
  upsert?: AcademicsUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface AcademicsUpdateDataInput {
  majors?: majorUpdateManyInput;
  colleges?: collegeUpdateManyInput;
}

export interface majorUpdateManyInput {
  create?: majorCreateInput[] | majorCreateInput;
  deleteMany?: majorScalarWhereInput[] | majorScalarWhereInput;
  updateMany?:
    | majorUpdateManyWithWhereNestedInput[]
    | majorUpdateManyWithWhereNestedInput;
}

export interface majorScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  AND?: majorScalarWhereInput[] | majorScalarWhereInput;
  OR?: majorScalarWhereInput[] | majorScalarWhereInput;
  NOT?: majorScalarWhereInput[] | majorScalarWhereInput;
}

export interface majorUpdateManyWithWhereNestedInput {
  where: majorScalarWhereInput;
  data: majorUpdateManyDataInput;
}

export interface majorUpdateManyDataInput {
  name?: String;
  rank?: Int;
}

export interface collegeUpdateManyInput {
  create?: collegeCreateInput[] | collegeCreateInput;
  deleteMany?: collegeScalarWhereInput[] | collegeScalarWhereInput;
  updateMany?:
    | collegeUpdateManyWithWhereNestedInput[]
    | collegeUpdateManyWithWhereNestedInput;
}

export interface collegeScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  AND?: collegeScalarWhereInput[] | collegeScalarWhereInput;
  OR?: collegeScalarWhereInput[] | collegeScalarWhereInput;
  NOT?: collegeScalarWhereInput[] | collegeScalarWhereInput;
}

export interface collegeUpdateManyWithWhereNestedInput {
  where: collegeScalarWhereInput;
  data: collegeUpdateManyDataInput;
}

export interface collegeUpdateManyDataInput {
  name?: String;
  rank?: Int;
}

export interface AcademicsUpsertNestedInput {
  update: AcademicsUpdateDataInput;
  create: AcademicsCreateInput;
}

export interface CostUpdateOneInput {
  create?: CostCreateInput;
  update?: CostUpdateDataInput;
  upsert?: CostUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface CostUpdateDataInput {
  tuitionUndergrad?: Int;
  tuitionGrad?: Int;
}

export interface CostUpsertNestedInput {
  update: CostUpdateDataInput;
  create: CostCreateInput;
}

export interface DemographicsUpdateOneInput {
  create?: DemographicsCreateInput;
  update?: DemographicsUpdateDataInput;
  upsert?: DemographicsUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface DemographicsUpdateDataInput {
  numStudents?: Int;
  numUndergraduates?: Int;
  numGraduates?: Int;
}

export interface DemographicsUpsertNestedInput {
  update: DemographicsUpdateDataInput;
  create: DemographicsCreateInput;
}

export interface GeographyUpdateOneInput {
  create?: GeographyCreateInput;
  update?: GeographyUpdateDataInput;
  upsert?: GeographyUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface GeographyUpdateDataInput {
  location?: LocationUpdateOneInput;
}

export interface GeographyUpsertNestedInput {
  update: GeographyUpdateDataInput;
  create: GeographyCreateInput;
}

export interface SchoolDetailsItemUpdateManyMutationInput {
  images?: SchoolDetailsItemUpdateimagesInput;
}

export interface SchoolListItemCreateInput {
  name?: String;
  usRanking?: RankingCreateOneInput;
  badges?: BadgeCreateManyInput;
  thumbnail?: String;
  acceptanceRate?: Float;
  actScores?: ActScoresCreateOneInput;
  satScores?: SatScoresCreateOneInput;
  toeflMinScore?: Int;
  regularDeadline?: DateTimeInput;
}

export interface RankingCreateOneInput {
  create?: RankingCreateInput;
}

export interface SchoolListItemUpdateInput {
  name?: String;
  usRanking?: RankingUpdateOneInput;
  badges?: BadgeUpdateManyInput;
  thumbnail?: String;
  acceptanceRate?: Float;
  actScores?: ActScoresUpdateOneInput;
  satScores?: SatScoresUpdateOneInput;
  toeflMinScore?: Int;
  regularDeadline?: DateTimeInput;
}

export interface RankingUpdateOneInput {
  create?: RankingCreateInput;
  update?: RankingUpdateDataInput;
  upsert?: RankingUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface RankingUpdateDataInput {
  name?: String;
  rank?: Int;
}

export interface RankingUpsertNestedInput {
  update: RankingUpdateDataInput;
  create: RankingCreateInput;
}

export interface SchoolListItemUpdateManyMutationInput {
  name?: String;
  thumbnail?: String;
  acceptanceRate?: Float;
  toeflMinScore?: Int;
  regularDeadline?: DateTimeInput;
}

export interface SchoolRecommendationCreateInput {
  names?: SchoolRecommendationCreatenamesInput;
}

export interface SchoolRecommendationCreatenamesInput {
  set?: String[] | String;
}

export interface SchoolRecommendationUpdateManyMutationInput {
  names?: SchoolRecommendationUpdatenamesInput;
}

export interface SchoolRecommendationUpdatenamesInput {
  set?: String[] | String;
}

export interface SchoolSuggestionCreateInput {
  names?: SchoolSuggestionCreatenamesInput;
}

export interface SchoolSuggestionCreatenamesInput {
  set?: String[] | String;
}

export interface SchoolSuggestionUpdateManyMutationInput {
  names?: SchoolSuggestionUpdatenamesInput;
}

export interface SchoolSuggestionUpdatenamesInput {
  set?: String[] | String;
}

export interface collegeUpdateManyMutationInput {
  name?: String;
  rank?: Int;
}

export interface majorUpdateManyMutationInput {
  name?: String;
  rank?: Int;
}

export interface AcademicsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AcademicsWhereInput;
  AND?: AcademicsSubscriptionWhereInput[] | AcademicsSubscriptionWhereInput;
  OR?: AcademicsSubscriptionWhereInput[] | AcademicsSubscriptionWhereInput;
  NOT?: AcademicsSubscriptionWhereInput[] | AcademicsSubscriptionWhereInput;
}

export interface ActScoresSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActScoresWhereInput;
  AND?: ActScoresSubscriptionWhereInput[] | ActScoresSubscriptionWhereInput;
  OR?: ActScoresSubscriptionWhereInput[] | ActScoresSubscriptionWhereInput;
  NOT?: ActScoresSubscriptionWhereInput[] | ActScoresSubscriptionWhereInput;
}

export interface ActScoresTemplateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActScoresTemplateWhereInput;
  AND?:
    | ActScoresTemplateSubscriptionWhereInput[]
    | ActScoresTemplateSubscriptionWhereInput;
  OR?:
    | ActScoresTemplateSubscriptionWhereInput[]
    | ActScoresTemplateSubscriptionWhereInput;
  NOT?:
    | ActScoresTemplateSubscriptionWhereInput[]
    | ActScoresTemplateSubscriptionWhereInput;
}

export interface AdmissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AdmissionWhereInput;
  AND?: AdmissionSubscriptionWhereInput[] | AdmissionSubscriptionWhereInput;
  OR?: AdmissionSubscriptionWhereInput[] | AdmissionSubscriptionWhereInput;
  NOT?: AdmissionSubscriptionWhereInput[] | AdmissionSubscriptionWhereInput;
}

export interface BadgeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BadgeWhereInput;
  AND?: BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput;
  OR?: BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput;
  NOT?: BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput;
}

export interface CostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CostWhereInput;
  AND?: CostSubscriptionWhereInput[] | CostSubscriptionWhereInput;
  OR?: CostSubscriptionWhereInput[] | CostSubscriptionWhereInput;
  NOT?: CostSubscriptionWhereInput[] | CostSubscriptionWhereInput;
}

export interface DemographicsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DemographicsWhereInput;
  AND?:
    | DemographicsSubscriptionWhereInput[]
    | DemographicsSubscriptionWhereInput;
  OR?:
    | DemographicsSubscriptionWhereInput[]
    | DemographicsSubscriptionWhereInput;
  NOT?:
    | DemographicsSubscriptionWhereInput[]
    | DemographicsSubscriptionWhereInput;
}

export interface GeographySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GeographyWhereInput;
  AND?: GeographySubscriptionWhereInput[] | GeographySubscriptionWhereInput;
  OR?: GeographySubscriptionWhereInput[] | GeographySubscriptionWhereInput;
  NOT?: GeographySubscriptionWhereInput[] | GeographySubscriptionWhereInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface OverviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OverviewWhereInput;
  AND?: OverviewSubscriptionWhereInput[] | OverviewSubscriptionWhereInput;
  OR?: OverviewSubscriptionWhereInput[] | OverviewSubscriptionWhereInput;
  NOT?: OverviewSubscriptionWhereInput[] | OverviewSubscriptionWhereInput;
}

export interface RankingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RankingWhereInput;
  AND?: RankingSubscriptionWhereInput[] | RankingSubscriptionWhereInput;
  OR?: RankingSubscriptionWhereInput[] | RankingSubscriptionWhereInput;
  NOT?: RankingSubscriptionWhereInput[] | RankingSubscriptionWhereInput;
}

export interface SatScoresSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SatScoresWhereInput;
  AND?: SatScoresSubscriptionWhereInput[] | SatScoresSubscriptionWhereInput;
  OR?: SatScoresSubscriptionWhereInput[] | SatScoresSubscriptionWhereInput;
  NOT?: SatScoresSubscriptionWhereInput[] | SatScoresSubscriptionWhereInput;
}

export interface SatScoresTemplateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SatScoresTemplateWhereInput;
  AND?:
    | SatScoresTemplateSubscriptionWhereInput[]
    | SatScoresTemplateSubscriptionWhereInput;
  OR?:
    | SatScoresTemplateSubscriptionWhereInput[]
    | SatScoresTemplateSubscriptionWhereInput;
  NOT?:
    | SatScoresTemplateSubscriptionWhereInput[]
    | SatScoresTemplateSubscriptionWhereInput;
}

export interface SchoolDetailsItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolDetailsItemWhereInput;
  AND?:
    | SchoolDetailsItemSubscriptionWhereInput[]
    | SchoolDetailsItemSubscriptionWhereInput;
  OR?:
    | SchoolDetailsItemSubscriptionWhereInput[]
    | SchoolDetailsItemSubscriptionWhereInput;
  NOT?:
    | SchoolDetailsItemSubscriptionWhereInput[]
    | SchoolDetailsItemSubscriptionWhereInput;
}

export interface SchoolListItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolListItemWhereInput;
  AND?:
    | SchoolListItemSubscriptionWhereInput[]
    | SchoolListItemSubscriptionWhereInput;
  OR?:
    | SchoolListItemSubscriptionWhereInput[]
    | SchoolListItemSubscriptionWhereInput;
  NOT?:
    | SchoolListItemSubscriptionWhereInput[]
    | SchoolListItemSubscriptionWhereInput;
}

export interface SchoolRecommendationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolRecommendationWhereInput;
  AND?:
    | SchoolRecommendationSubscriptionWhereInput[]
    | SchoolRecommendationSubscriptionWhereInput;
  OR?:
    | SchoolRecommendationSubscriptionWhereInput[]
    | SchoolRecommendationSubscriptionWhereInput;
  NOT?:
    | SchoolRecommendationSubscriptionWhereInput[]
    | SchoolRecommendationSubscriptionWhereInput;
}

export interface SchoolSuggestionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolSuggestionWhereInput;
  AND?:
    | SchoolSuggestionSubscriptionWhereInput[]
    | SchoolSuggestionSubscriptionWhereInput;
  OR?:
    | SchoolSuggestionSubscriptionWhereInput[]
    | SchoolSuggestionSubscriptionWhereInput;
  NOT?:
    | SchoolSuggestionSubscriptionWhereInput[]
    | SchoolSuggestionSubscriptionWhereInput;
}

export interface collegeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: collegeWhereInput;
  AND?: collegeSubscriptionWhereInput[] | collegeSubscriptionWhereInput;
  OR?: collegeSubscriptionWhereInput[] | collegeSubscriptionWhereInput;
  NOT?: collegeSubscriptionWhereInput[] | collegeSubscriptionWhereInput;
}

export interface majorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: majorWhereInput;
  AND?: majorSubscriptionWhereInput[] | majorSubscriptionWhereInput;
  OR?: majorSubscriptionWhereInput[] | majorSubscriptionWhereInput;
  NOT?: majorSubscriptionWhereInput[] | majorSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Academics {}

export interface AcademicsPromise extends Promise<Academics>, Fragmentable {
  majors: <T = FragmentableArray<major>>(args?: {
    where?: majorWhereInput;
    orderBy?: majorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  colleges: <T = FragmentableArray<college>>(args?: {
    where?: collegeWhereInput;
    orderBy?: collegeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AcademicsSubscription
  extends Promise<AsyncIterator<Academics>>,
    Fragmentable {
  majors: <T = Promise<AsyncIterator<majorSubscription>>>(args?: {
    where?: majorWhereInput;
    orderBy?: majorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  colleges: <T = Promise<AsyncIterator<collegeSubscription>>>(args?: {
    where?: collegeWhereInput;
    orderBy?: collegeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface major {
  name?: String;
  rank?: Int;
}

export interface majorPromise extends Promise<major>, Fragmentable {
  name: () => Promise<String>;
  rank: () => Promise<Int>;
}

export interface majorSubscription
  extends Promise<AsyncIterator<major>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
}

export interface college {
  name?: String;
  rank?: Int;
}

export interface collegePromise extends Promise<college>, Fragmentable {
  name: () => Promise<String>;
  rank: () => Promise<Int>;
}

export interface collegeSubscription
  extends Promise<AsyncIterator<college>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
}

export interface AcademicsConnection {
  pageInfo: PageInfo;
  edges: AcademicsEdge[];
}

export interface AcademicsConnectionPromise
  extends Promise<AcademicsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AcademicsEdge>>() => T;
  aggregate: <T = AggregateAcademicsPromise>() => T;
}

export interface AcademicsConnectionSubscription
  extends Promise<AsyncIterator<AcademicsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AcademicsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAcademicsSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AcademicsEdge {
  node: Academics;
  cursor: String;
}

export interface AcademicsEdgePromise
  extends Promise<AcademicsEdge>,
    Fragmentable {
  node: <T = AcademicsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AcademicsEdgeSubscription
  extends Promise<AsyncIterator<AcademicsEdge>>,
    Fragmentable {
  node: <T = AcademicsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAcademics {
  count: Int;
}

export interface AggregateAcademicsPromise
  extends Promise<AggregateAcademics>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAcademicsSubscription
  extends Promise<AsyncIterator<AggregateAcademics>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActScores {}

export interface ActScoresPromise extends Promise<ActScores>, Fragmentable {
  percentile25th: <T = ActScoresTemplatePromise>() => T;
  mid: <T = ActScoresTemplatePromise>() => T;
  percentile75th: <T = ActScoresTemplatePromise>() => T;
}

export interface ActScoresSubscription
  extends Promise<AsyncIterator<ActScores>>,
    Fragmentable {
  percentile25th: <T = ActScoresTemplateSubscription>() => T;
  mid: <T = ActScoresTemplateSubscription>() => T;
  percentile75th: <T = ActScoresTemplateSubscription>() => T;
}

export interface ActScoresTemplate {
  writing?: Int;
  english?: Int;
  math?: Int;
  cumulative?: Int;
}

export interface ActScoresTemplatePromise
  extends Promise<ActScoresTemplate>,
    Fragmentable {
  writing: () => Promise<Int>;
  english: () => Promise<Int>;
  math: () => Promise<Int>;
  cumulative: () => Promise<Int>;
}

export interface ActScoresTemplateSubscription
  extends Promise<AsyncIterator<ActScoresTemplate>>,
    Fragmentable {
  writing: () => Promise<AsyncIterator<Int>>;
  english: () => Promise<AsyncIterator<Int>>;
  math: () => Promise<AsyncIterator<Int>>;
  cumulative: () => Promise<AsyncIterator<Int>>;
}

export interface ActScoresConnection {
  pageInfo: PageInfo;
  edges: ActScoresEdge[];
}

export interface ActScoresConnectionPromise
  extends Promise<ActScoresConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActScoresEdge>>() => T;
  aggregate: <T = AggregateActScoresPromise>() => T;
}

export interface ActScoresConnectionSubscription
  extends Promise<AsyncIterator<ActScoresConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActScoresEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActScoresSubscription>() => T;
}

export interface ActScoresEdge {
  node: ActScores;
  cursor: String;
}

export interface ActScoresEdgePromise
  extends Promise<ActScoresEdge>,
    Fragmentable {
  node: <T = ActScoresPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActScoresEdgeSubscription
  extends Promise<AsyncIterator<ActScoresEdge>>,
    Fragmentable {
  node: <T = ActScoresSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActScores {
  count: Int;
}

export interface AggregateActScoresPromise
  extends Promise<AggregateActScores>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActScoresSubscription
  extends Promise<AsyncIterator<AggregateActScores>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActScoresTemplateConnection {
  pageInfo: PageInfo;
  edges: ActScoresTemplateEdge[];
}

export interface ActScoresTemplateConnectionPromise
  extends Promise<ActScoresTemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActScoresTemplateEdge>>() => T;
  aggregate: <T = AggregateActScoresTemplatePromise>() => T;
}

export interface ActScoresTemplateConnectionSubscription
  extends Promise<AsyncIterator<ActScoresTemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActScoresTemplateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActScoresTemplateSubscription>() => T;
}

export interface ActScoresTemplateEdge {
  node: ActScoresTemplate;
  cursor: String;
}

export interface ActScoresTemplateEdgePromise
  extends Promise<ActScoresTemplateEdge>,
    Fragmentable {
  node: <T = ActScoresTemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActScoresTemplateEdgeSubscription
  extends Promise<AsyncIterator<ActScoresTemplateEdge>>,
    Fragmentable {
  node: <T = ActScoresTemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActScoresTemplate {
  count: Int;
}

export interface AggregateActScoresTemplatePromise
  extends Promise<AggregateActScoresTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActScoresTemplateSubscription
  extends Promise<AsyncIterator<AggregateActScoresTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Admission {
  acceptanceRate?: Float;
  toeflMinScore?: Int;
  ieltsMinScore?: Int;
  earlyDecisionDeadline?: DateTimeOutput;
  regularDeadline?: DateTimeOutput;
  schoolResponseDeadline?: DateTimeOutput;
  studentResponseDeadline?: DateTimeOutput;
}

export interface AdmissionPromise extends Promise<Admission>, Fragmentable {
  acceptanceRate: () => Promise<Float>;
  actScores: <T = ActScoresPromise>() => T;
  satScores: <T = SatScoresPromise>() => T;
  toeflMinScore: () => Promise<Int>;
  ieltsMinScore: () => Promise<Int>;
  earlyDecisionDeadline: () => Promise<DateTimeOutput>;
  regularDeadline: () => Promise<DateTimeOutput>;
  schoolResponseDeadline: () => Promise<DateTimeOutput>;
  studentResponseDeadline: () => Promise<DateTimeOutput>;
}

export interface AdmissionSubscription
  extends Promise<AsyncIterator<Admission>>,
    Fragmentable {
  acceptanceRate: () => Promise<AsyncIterator<Float>>;
  actScores: <T = ActScoresSubscription>() => T;
  satScores: <T = SatScoresSubscription>() => T;
  toeflMinScore: () => Promise<AsyncIterator<Int>>;
  ieltsMinScore: () => Promise<AsyncIterator<Int>>;
  earlyDecisionDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  regularDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  schoolResponseDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  studentResponseDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SatScores {}

export interface SatScoresPromise extends Promise<SatScores>, Fragmentable {
  percentile25th: <T = SatScoresTemplatePromise>() => T;
  mid: <T = SatScoresTemplatePromise>() => T;
  percentile75th: <T = SatScoresTemplatePromise>() => T;
}

export interface SatScoresSubscription
  extends Promise<AsyncIterator<SatScores>>,
    Fragmentable {
  percentile25th: <T = SatScoresTemplateSubscription>() => T;
  mid: <T = SatScoresTemplateSubscription>() => T;
  percentile75th: <T = SatScoresTemplateSubscription>() => T;
}

export interface SatScoresTemplate {
  reading?: Int;
  writing?: Int;
  math?: Int;
}

export interface SatScoresTemplatePromise
  extends Promise<SatScoresTemplate>,
    Fragmentable {
  reading: () => Promise<Int>;
  writing: () => Promise<Int>;
  math: () => Promise<Int>;
}

export interface SatScoresTemplateSubscription
  extends Promise<AsyncIterator<SatScoresTemplate>>,
    Fragmentable {
  reading: () => Promise<AsyncIterator<Int>>;
  writing: () => Promise<AsyncIterator<Int>>;
  math: () => Promise<AsyncIterator<Int>>;
}

export interface AdmissionConnection {
  pageInfo: PageInfo;
  edges: AdmissionEdge[];
}

export interface AdmissionConnectionPromise
  extends Promise<AdmissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdmissionEdge>>() => T;
  aggregate: <T = AggregateAdmissionPromise>() => T;
}

export interface AdmissionConnectionSubscription
  extends Promise<AsyncIterator<AdmissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdmissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdmissionSubscription>() => T;
}

export interface AdmissionEdge {
  node: Admission;
  cursor: String;
}

export interface AdmissionEdgePromise
  extends Promise<AdmissionEdge>,
    Fragmentable {
  node: <T = AdmissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdmissionEdgeSubscription
  extends Promise<AsyncIterator<AdmissionEdge>>,
    Fragmentable {
  node: <T = AdmissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdmission {
  count: Int;
}

export interface AggregateAdmissionPromise
  extends Promise<AggregateAdmission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdmissionSubscription
  extends Promise<AsyncIterator<AggregateAdmission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Badge {
  tooltip?: String;
  url?: String;
}

export interface BadgePromise extends Promise<Badge>, Fragmentable {
  tooltip: () => Promise<String>;
  url: () => Promise<String>;
}

export interface BadgeSubscription
  extends Promise<AsyncIterator<Badge>>,
    Fragmentable {
  tooltip: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface BadgeConnection {
  pageInfo: PageInfo;
  edges: BadgeEdge[];
}

export interface BadgeConnectionPromise
  extends Promise<BadgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BadgeEdge>>() => T;
  aggregate: <T = AggregateBadgePromise>() => T;
}

export interface BadgeConnectionSubscription
  extends Promise<AsyncIterator<BadgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BadgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBadgeSubscription>() => T;
}

export interface BadgeEdge {
  node: Badge;
  cursor: String;
}

export interface BadgeEdgePromise extends Promise<BadgeEdge>, Fragmentable {
  node: <T = BadgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BadgeEdgeSubscription
  extends Promise<AsyncIterator<BadgeEdge>>,
    Fragmentable {
  node: <T = BadgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBadge {
  count: Int;
}

export interface AggregateBadgePromise
  extends Promise<AggregateBadge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBadgeSubscription
  extends Promise<AsyncIterator<AggregateBadge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Cost {
  tuitionUndergrad?: Int;
  tuitionGrad?: Int;
}

export interface CostPromise extends Promise<Cost>, Fragmentable {
  tuitionUndergrad: () => Promise<Int>;
  tuitionGrad: () => Promise<Int>;
}

export interface CostSubscription
  extends Promise<AsyncIterator<Cost>>,
    Fragmentable {
  tuitionUndergrad: () => Promise<AsyncIterator<Int>>;
  tuitionGrad: () => Promise<AsyncIterator<Int>>;
}

export interface CostConnection {
  pageInfo: PageInfo;
  edges: CostEdge[];
}

export interface CostConnectionPromise
  extends Promise<CostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CostEdge>>() => T;
  aggregate: <T = AggregateCostPromise>() => T;
}

export interface CostConnectionSubscription
  extends Promise<AsyncIterator<CostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CostEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCostSubscription>() => T;
}

export interface CostEdge {
  node: Cost;
  cursor: String;
}

export interface CostEdgePromise extends Promise<CostEdge>, Fragmentable {
  node: <T = CostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CostEdgeSubscription
  extends Promise<AsyncIterator<CostEdge>>,
    Fragmentable {
  node: <T = CostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCost {
  count: Int;
}

export interface AggregateCostPromise
  extends Promise<AggregateCost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCostSubscription
  extends Promise<AsyncIterator<AggregateCost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Demographics {
  numStudents?: Int;
  numUndergraduates?: Int;
  numGraduates?: Int;
}

export interface DemographicsPromise
  extends Promise<Demographics>,
    Fragmentable {
  numStudents: () => Promise<Int>;
  numUndergraduates: () => Promise<Int>;
  numGraduates: () => Promise<Int>;
}

export interface DemographicsSubscription
  extends Promise<AsyncIterator<Demographics>>,
    Fragmentable {
  numStudents: () => Promise<AsyncIterator<Int>>;
  numUndergraduates: () => Promise<AsyncIterator<Int>>;
  numGraduates: () => Promise<AsyncIterator<Int>>;
}

export interface DemographicsConnection {
  pageInfo: PageInfo;
  edges: DemographicsEdge[];
}

export interface DemographicsConnectionPromise
  extends Promise<DemographicsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DemographicsEdge>>() => T;
  aggregate: <T = AggregateDemographicsPromise>() => T;
}

export interface DemographicsConnectionSubscription
  extends Promise<AsyncIterator<DemographicsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DemographicsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDemographicsSubscription>() => T;
}

export interface DemographicsEdge {
  node: Demographics;
  cursor: String;
}

export interface DemographicsEdgePromise
  extends Promise<DemographicsEdge>,
    Fragmentable {
  node: <T = DemographicsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DemographicsEdgeSubscription
  extends Promise<AsyncIterator<DemographicsEdge>>,
    Fragmentable {
  node: <T = DemographicsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDemographics {
  count: Int;
}

export interface AggregateDemographicsPromise
  extends Promise<AggregateDemographics>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDemographicsSubscription
  extends Promise<AsyncIterator<AggregateDemographics>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Geography {}

export interface GeographyPromise extends Promise<Geography>, Fragmentable {
  location: <T = LocationPromise>() => T;
}

export interface GeographySubscription
  extends Promise<AsyncIterator<Geography>>,
    Fragmentable {
  location: <T = LocationSubscription>() => T;
}

export interface Location {
  latittude?: Float;
  longitude?: Float;
  state?: String;
  city?: String;
  zip?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  latittude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  state: () => Promise<String>;
  city: () => Promise<String>;
  zip: () => Promise<String>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  latittude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  state: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface GeographyConnection {
  pageInfo: PageInfo;
  edges: GeographyEdge[];
}

export interface GeographyConnectionPromise
  extends Promise<GeographyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GeographyEdge>>() => T;
  aggregate: <T = AggregateGeographyPromise>() => T;
}

export interface GeographyConnectionSubscription
  extends Promise<AsyncIterator<GeographyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GeographyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGeographySubscription>() => T;
}

export interface GeographyEdge {
  node: Geography;
  cursor: String;
}

export interface GeographyEdgePromise
  extends Promise<GeographyEdge>,
    Fragmentable {
  node: <T = GeographyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GeographyEdgeSubscription
  extends Promise<AsyncIterator<GeographyEdge>>,
    Fragmentable {
  node: <T = GeographySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGeography {
  count: Int;
}

export interface AggregateGeographyPromise
  extends Promise<AggregateGeography>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGeographySubscription
  extends Promise<AsyncIterator<AggregateGeography>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Overview {
  name: String;
  description?: String;
  url?: String;
  menOnly?: Boolean;
  womenOnly?: Boolean;
  operating?: Boolean;
  onlineOnly?: Boolean;
  deadline?: DateTimeOutput;
  system?: System;
}

export interface OverviewPromise extends Promise<Overview>, Fragmentable {
  name: () => Promise<String>;
  description: () => Promise<String>;
  notableRankings: <T = FragmentableArray<Ranking>>(args?: {
    where?: RankingWhereInput;
    orderBy?: RankingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  badges: <T = FragmentableArray<Badge>>(args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = LocationPromise>() => T;
  url: () => Promise<String>;
  menOnly: () => Promise<Boolean>;
  womenOnly: () => Promise<Boolean>;
  operating: () => Promise<Boolean>;
  onlineOnly: () => Promise<Boolean>;
  deadline: () => Promise<DateTimeOutput>;
  system: () => Promise<System>;
}

export interface OverviewSubscription
  extends Promise<AsyncIterator<Overview>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  notableRankings: <T = Promise<AsyncIterator<RankingSubscription>>>(args?: {
    where?: RankingWhereInput;
    orderBy?: RankingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  badges: <T = Promise<AsyncIterator<BadgeSubscription>>>(args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  location: <T = LocationSubscription>() => T;
  url: () => Promise<AsyncIterator<String>>;
  menOnly: () => Promise<AsyncIterator<Boolean>>;
  womenOnly: () => Promise<AsyncIterator<Boolean>>;
  operating: () => Promise<AsyncIterator<Boolean>>;
  onlineOnly: () => Promise<AsyncIterator<Boolean>>;
  deadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  system: () => Promise<AsyncIterator<System>>;
}

export interface Ranking {
  name?: String;
  rank?: Int;
}

export interface RankingPromise extends Promise<Ranking>, Fragmentable {
  name: () => Promise<String>;
  rank: () => Promise<Int>;
}

export interface RankingSubscription
  extends Promise<AsyncIterator<Ranking>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
}

export interface OverviewConnection {
  pageInfo: PageInfo;
  edges: OverviewEdge[];
}

export interface OverviewConnectionPromise
  extends Promise<OverviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OverviewEdge>>() => T;
  aggregate: <T = AggregateOverviewPromise>() => T;
}

export interface OverviewConnectionSubscription
  extends Promise<AsyncIterator<OverviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OverviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOverviewSubscription>() => T;
}

export interface OverviewEdge {
  node: Overview;
  cursor: String;
}

export interface OverviewEdgePromise
  extends Promise<OverviewEdge>,
    Fragmentable {
  node: <T = OverviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OverviewEdgeSubscription
  extends Promise<AsyncIterator<OverviewEdge>>,
    Fragmentable {
  node: <T = OverviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOverview {
  count: Int;
}

export interface AggregateOverviewPromise
  extends Promise<AggregateOverview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOverviewSubscription
  extends Promise<AsyncIterator<AggregateOverview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RankingConnection {
  pageInfo: PageInfo;
  edges: RankingEdge[];
}

export interface RankingConnectionPromise
  extends Promise<RankingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RankingEdge>>() => T;
  aggregate: <T = AggregateRankingPromise>() => T;
}

export interface RankingConnectionSubscription
  extends Promise<AsyncIterator<RankingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RankingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRankingSubscription>() => T;
}

export interface RankingEdge {
  node: Ranking;
  cursor: String;
}

export interface RankingEdgePromise extends Promise<RankingEdge>, Fragmentable {
  node: <T = RankingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RankingEdgeSubscription
  extends Promise<AsyncIterator<RankingEdge>>,
    Fragmentable {
  node: <T = RankingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRanking {
  count: Int;
}

export interface AggregateRankingPromise
  extends Promise<AggregateRanking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRankingSubscription
  extends Promise<AsyncIterator<AggregateRanking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SatScoresConnection {
  pageInfo: PageInfo;
  edges: SatScoresEdge[];
}

export interface SatScoresConnectionPromise
  extends Promise<SatScoresConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SatScoresEdge>>() => T;
  aggregate: <T = AggregateSatScoresPromise>() => T;
}

export interface SatScoresConnectionSubscription
  extends Promise<AsyncIterator<SatScoresConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SatScoresEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSatScoresSubscription>() => T;
}

export interface SatScoresEdge {
  node: SatScores;
  cursor: String;
}

export interface SatScoresEdgePromise
  extends Promise<SatScoresEdge>,
    Fragmentable {
  node: <T = SatScoresPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SatScoresEdgeSubscription
  extends Promise<AsyncIterator<SatScoresEdge>>,
    Fragmentable {
  node: <T = SatScoresSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSatScores {
  count: Int;
}

export interface AggregateSatScoresPromise
  extends Promise<AggregateSatScores>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSatScoresSubscription
  extends Promise<AsyncIterator<AggregateSatScores>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SatScoresTemplateConnection {
  pageInfo: PageInfo;
  edges: SatScoresTemplateEdge[];
}

export interface SatScoresTemplateConnectionPromise
  extends Promise<SatScoresTemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SatScoresTemplateEdge>>() => T;
  aggregate: <T = AggregateSatScoresTemplatePromise>() => T;
}

export interface SatScoresTemplateConnectionSubscription
  extends Promise<AsyncIterator<SatScoresTemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SatScoresTemplateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSatScoresTemplateSubscription>() => T;
}

export interface SatScoresTemplateEdge {
  node: SatScoresTemplate;
  cursor: String;
}

export interface SatScoresTemplateEdgePromise
  extends Promise<SatScoresTemplateEdge>,
    Fragmentable {
  node: <T = SatScoresTemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SatScoresTemplateEdgeSubscription
  extends Promise<AsyncIterator<SatScoresTemplateEdge>>,
    Fragmentable {
  node: <T = SatScoresTemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSatScoresTemplate {
  count: Int;
}

export interface AggregateSatScoresTemplatePromise
  extends Promise<AggregateSatScoresTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSatScoresTemplateSubscription
  extends Promise<AsyncIterator<AggregateSatScoresTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolDetailsItem {
  id: ID_Output;
  images: String[];
}

export interface SchoolDetailsItemPromise
  extends Promise<SchoolDetailsItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  overview: <T = OverviewPromise>() => T;
  images: () => Promise<String[]>;
  admission: <T = AdmissionPromise>() => T;
  academics: <T = AcademicsPromise>() => T;
  cost: <T = CostPromise>() => T;
  demographics: <T = DemographicsPromise>() => T;
  geography: <T = GeographyPromise>() => T;
}

export interface SchoolDetailsItemSubscription
  extends Promise<AsyncIterator<SchoolDetailsItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  overview: <T = OverviewSubscription>() => T;
  images: () => Promise<AsyncIterator<String[]>>;
  admission: <T = AdmissionSubscription>() => T;
  academics: <T = AcademicsSubscription>() => T;
  cost: <T = CostSubscription>() => T;
  demographics: <T = DemographicsSubscription>() => T;
  geography: <T = GeographySubscription>() => T;
}

export interface SchoolDetailsItemConnection {
  pageInfo: PageInfo;
  edges: SchoolDetailsItemEdge[];
}

export interface SchoolDetailsItemConnectionPromise
  extends Promise<SchoolDetailsItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolDetailsItemEdge>>() => T;
  aggregate: <T = AggregateSchoolDetailsItemPromise>() => T;
}

export interface SchoolDetailsItemConnectionSubscription
  extends Promise<AsyncIterator<SchoolDetailsItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolDetailsItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolDetailsItemSubscription>() => T;
}

export interface SchoolDetailsItemEdge {
  node: SchoolDetailsItem;
  cursor: String;
}

export interface SchoolDetailsItemEdgePromise
  extends Promise<SchoolDetailsItemEdge>,
    Fragmentable {
  node: <T = SchoolDetailsItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolDetailsItemEdgeSubscription
  extends Promise<AsyncIterator<SchoolDetailsItemEdge>>,
    Fragmentable {
  node: <T = SchoolDetailsItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchoolDetailsItem {
  count: Int;
}

export interface AggregateSchoolDetailsItemPromise
  extends Promise<AggregateSchoolDetailsItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolDetailsItemSubscription
  extends Promise<AsyncIterator<AggregateSchoolDetailsItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolListItem {
  id: ID_Output;
  name?: String;
  thumbnail?: String;
  acceptanceRate?: Float;
  toeflMinScore?: Int;
  regularDeadline?: DateTimeOutput;
}

export interface SchoolListItemPromise
  extends Promise<SchoolListItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  usRanking: <T = RankingPromise>() => T;
  badges: <T = FragmentableArray<Badge>>(args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnail: () => Promise<String>;
  acceptanceRate: () => Promise<Float>;
  actScores: <T = ActScoresPromise>() => T;
  satScores: <T = SatScoresPromise>() => T;
  toeflMinScore: () => Promise<Int>;
  regularDeadline: () => Promise<DateTimeOutput>;
}

export interface SchoolListItemSubscription
  extends Promise<AsyncIterator<SchoolListItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  usRanking: <T = RankingSubscription>() => T;
  badges: <T = Promise<AsyncIterator<BadgeSubscription>>>(args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnail: () => Promise<AsyncIterator<String>>;
  acceptanceRate: () => Promise<AsyncIterator<Float>>;
  actScores: <T = ActScoresSubscription>() => T;
  satScores: <T = SatScoresSubscription>() => T;
  toeflMinScore: () => Promise<AsyncIterator<Int>>;
  regularDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SchoolListItemConnection {
  pageInfo: PageInfo;
  edges: SchoolListItemEdge[];
}

export interface SchoolListItemConnectionPromise
  extends Promise<SchoolListItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolListItemEdge>>() => T;
  aggregate: <T = AggregateSchoolListItemPromise>() => T;
}

export interface SchoolListItemConnectionSubscription
  extends Promise<AsyncIterator<SchoolListItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolListItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolListItemSubscription>() => T;
}

export interface SchoolListItemEdge {
  node: SchoolListItem;
  cursor: String;
}

export interface SchoolListItemEdgePromise
  extends Promise<SchoolListItemEdge>,
    Fragmentable {
  node: <T = SchoolListItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolListItemEdgeSubscription
  extends Promise<AsyncIterator<SchoolListItemEdge>>,
    Fragmentable {
  node: <T = SchoolListItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchoolListItem {
  count: Int;
}

export interface AggregateSchoolListItemPromise
  extends Promise<AggregateSchoolListItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolListItemSubscription
  extends Promise<AsyncIterator<AggregateSchoolListItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolRecommendation {
  names: String[];
}

export interface SchoolRecommendationPromise
  extends Promise<SchoolRecommendation>,
    Fragmentable {
  names: () => Promise<String[]>;
}

export interface SchoolRecommendationSubscription
  extends Promise<AsyncIterator<SchoolRecommendation>>,
    Fragmentable {
  names: () => Promise<AsyncIterator<String[]>>;
}

export interface SchoolRecommendationConnection {
  pageInfo: PageInfo;
  edges: SchoolRecommendationEdge[];
}

export interface SchoolRecommendationConnectionPromise
  extends Promise<SchoolRecommendationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolRecommendationEdge>>() => T;
  aggregate: <T = AggregateSchoolRecommendationPromise>() => T;
}

export interface SchoolRecommendationConnectionSubscription
  extends Promise<AsyncIterator<SchoolRecommendationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SchoolRecommendationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSchoolRecommendationSubscription>() => T;
}

export interface SchoolRecommendationEdge {
  node: SchoolRecommendation;
  cursor: String;
}

export interface SchoolRecommendationEdgePromise
  extends Promise<SchoolRecommendationEdge>,
    Fragmentable {
  node: <T = SchoolRecommendationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolRecommendationEdgeSubscription
  extends Promise<AsyncIterator<SchoolRecommendationEdge>>,
    Fragmentable {
  node: <T = SchoolRecommendationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchoolRecommendation {
  count: Int;
}

export interface AggregateSchoolRecommendationPromise
  extends Promise<AggregateSchoolRecommendation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolRecommendationSubscription
  extends Promise<AsyncIterator<AggregateSchoolRecommendation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolSuggestion {
  names: String[];
}

export interface SchoolSuggestionPromise
  extends Promise<SchoolSuggestion>,
    Fragmentable {
  names: () => Promise<String[]>;
}

export interface SchoolSuggestionSubscription
  extends Promise<AsyncIterator<SchoolSuggestion>>,
    Fragmentable {
  names: () => Promise<AsyncIterator<String[]>>;
}

export interface SchoolSuggestionConnection {
  pageInfo: PageInfo;
  edges: SchoolSuggestionEdge[];
}

export interface SchoolSuggestionConnectionPromise
  extends Promise<SchoolSuggestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolSuggestionEdge>>() => T;
  aggregate: <T = AggregateSchoolSuggestionPromise>() => T;
}

export interface SchoolSuggestionConnectionSubscription
  extends Promise<AsyncIterator<SchoolSuggestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolSuggestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolSuggestionSubscription>() => T;
}

export interface SchoolSuggestionEdge {
  node: SchoolSuggestion;
  cursor: String;
}

export interface SchoolSuggestionEdgePromise
  extends Promise<SchoolSuggestionEdge>,
    Fragmentable {
  node: <T = SchoolSuggestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolSuggestionEdgeSubscription
  extends Promise<AsyncIterator<SchoolSuggestionEdge>>,
    Fragmentable {
  node: <T = SchoolSuggestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchoolSuggestion {
  count: Int;
}

export interface AggregateSchoolSuggestionPromise
  extends Promise<AggregateSchoolSuggestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolSuggestionSubscription
  extends Promise<AsyncIterator<AggregateSchoolSuggestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface collegeConnection {
  pageInfo: PageInfo;
  edges: collegeEdge[];
}

export interface collegeConnectionPromise
  extends Promise<collegeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<collegeEdge>>() => T;
  aggregate: <T = AggregatecollegePromise>() => T;
}

export interface collegeConnectionSubscription
  extends Promise<AsyncIterator<collegeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<collegeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatecollegeSubscription>() => T;
}

export interface collegeEdge {
  node: college;
  cursor: String;
}

export interface collegeEdgePromise extends Promise<collegeEdge>, Fragmentable {
  node: <T = collegePromise>() => T;
  cursor: () => Promise<String>;
}

export interface collegeEdgeSubscription
  extends Promise<AsyncIterator<collegeEdge>>,
    Fragmentable {
  node: <T = collegeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatecollege {
  count: Int;
}

export interface AggregatecollegePromise
  extends Promise<Aggregatecollege>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatecollegeSubscription
  extends Promise<AsyncIterator<Aggregatecollege>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface majorConnection {
  pageInfo: PageInfo;
  edges: majorEdge[];
}

export interface majorConnectionPromise
  extends Promise<majorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<majorEdge>>() => T;
  aggregate: <T = AggregatemajorPromise>() => T;
}

export interface majorConnectionSubscription
  extends Promise<AsyncIterator<majorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<majorEdgeSubscription>>>() => T;
  aggregate: <T = AggregatemajorSubscription>() => T;
}

export interface majorEdge {
  node: major;
  cursor: String;
}

export interface majorEdgePromise extends Promise<majorEdge>, Fragmentable {
  node: <T = majorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface majorEdgeSubscription
  extends Promise<AsyncIterator<majorEdge>>,
    Fragmentable {
  node: <T = majorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatemajor {
  count: Int;
}

export interface AggregatemajorPromise
  extends Promise<Aggregatemajor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatemajorSubscription
  extends Promise<AsyncIterator<Aggregatemajor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AcademicsSubscriptionPayload {
  mutation: MutationType;
  node: Academics;
  updatedFields: String[];
}

export interface AcademicsSubscriptionPayloadPromise
  extends Promise<AcademicsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AcademicsPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface AcademicsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AcademicsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AcademicsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface ActScoresSubscriptionPayload {
  mutation: MutationType;
  node: ActScores;
  updatedFields: String[];
}

export interface ActScoresSubscriptionPayloadPromise
  extends Promise<ActScoresSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActScoresPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface ActScoresSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActScoresSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActScoresSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface ActScoresTemplateSubscriptionPayload {
  mutation: MutationType;
  node: ActScoresTemplate;
  updatedFields: String[];
  previousValues: ActScoresTemplatePreviousValues;
}

export interface ActScoresTemplateSubscriptionPayloadPromise
  extends Promise<ActScoresTemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActScoresTemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActScoresTemplatePreviousValuesPromise>() => T;
}

export interface ActScoresTemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActScoresTemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActScoresTemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActScoresTemplatePreviousValuesSubscription>() => T;
}

export interface ActScoresTemplatePreviousValues {
  writing?: Int;
  english?: Int;
  math?: Int;
  cumulative?: Int;
}

export interface ActScoresTemplatePreviousValuesPromise
  extends Promise<ActScoresTemplatePreviousValues>,
    Fragmentable {
  writing: () => Promise<Int>;
  english: () => Promise<Int>;
  math: () => Promise<Int>;
  cumulative: () => Promise<Int>;
}

export interface ActScoresTemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<ActScoresTemplatePreviousValues>>,
    Fragmentable {
  writing: () => Promise<AsyncIterator<Int>>;
  english: () => Promise<AsyncIterator<Int>>;
  math: () => Promise<AsyncIterator<Int>>;
  cumulative: () => Promise<AsyncIterator<Int>>;
}

export interface AdmissionSubscriptionPayload {
  mutation: MutationType;
  node: Admission;
  updatedFields: String[];
  previousValues: AdmissionPreviousValues;
}

export interface AdmissionSubscriptionPayloadPromise
  extends Promise<AdmissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdmissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdmissionPreviousValuesPromise>() => T;
}

export interface AdmissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdmissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdmissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdmissionPreviousValuesSubscription>() => T;
}

export interface AdmissionPreviousValues {
  acceptanceRate?: Float;
  toeflMinScore?: Int;
  ieltsMinScore?: Int;
  earlyDecisionDeadline?: DateTimeOutput;
  regularDeadline?: DateTimeOutput;
  schoolResponseDeadline?: DateTimeOutput;
  studentResponseDeadline?: DateTimeOutput;
}

export interface AdmissionPreviousValuesPromise
  extends Promise<AdmissionPreviousValues>,
    Fragmentable {
  acceptanceRate: () => Promise<Float>;
  toeflMinScore: () => Promise<Int>;
  ieltsMinScore: () => Promise<Int>;
  earlyDecisionDeadline: () => Promise<DateTimeOutput>;
  regularDeadline: () => Promise<DateTimeOutput>;
  schoolResponseDeadline: () => Promise<DateTimeOutput>;
  studentResponseDeadline: () => Promise<DateTimeOutput>;
}

export interface AdmissionPreviousValuesSubscription
  extends Promise<AsyncIterator<AdmissionPreviousValues>>,
    Fragmentable {
  acceptanceRate: () => Promise<AsyncIterator<Float>>;
  toeflMinScore: () => Promise<AsyncIterator<Int>>;
  ieltsMinScore: () => Promise<AsyncIterator<Int>>;
  earlyDecisionDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  regularDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  schoolResponseDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  studentResponseDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BadgeSubscriptionPayload {
  mutation: MutationType;
  node: Badge;
  updatedFields: String[];
  previousValues: BadgePreviousValues;
}

export interface BadgeSubscriptionPayloadPromise
  extends Promise<BadgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BadgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BadgePreviousValuesPromise>() => T;
}

export interface BadgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BadgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BadgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BadgePreviousValuesSubscription>() => T;
}

export interface BadgePreviousValues {
  tooltip?: String;
  url?: String;
}

export interface BadgePreviousValuesPromise
  extends Promise<BadgePreviousValues>,
    Fragmentable {
  tooltip: () => Promise<String>;
  url: () => Promise<String>;
}

export interface BadgePreviousValuesSubscription
  extends Promise<AsyncIterator<BadgePreviousValues>>,
    Fragmentable {
  tooltip: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface CostSubscriptionPayload {
  mutation: MutationType;
  node: Cost;
  updatedFields: String[];
  previousValues: CostPreviousValues;
}

export interface CostSubscriptionPayloadPromise
  extends Promise<CostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CostPreviousValuesPromise>() => T;
}

export interface CostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CostPreviousValuesSubscription>() => T;
}

export interface CostPreviousValues {
  tuitionUndergrad?: Int;
  tuitionGrad?: Int;
}

export interface CostPreviousValuesPromise
  extends Promise<CostPreviousValues>,
    Fragmentable {
  tuitionUndergrad: () => Promise<Int>;
  tuitionGrad: () => Promise<Int>;
}

export interface CostPreviousValuesSubscription
  extends Promise<AsyncIterator<CostPreviousValues>>,
    Fragmentable {
  tuitionUndergrad: () => Promise<AsyncIterator<Int>>;
  tuitionGrad: () => Promise<AsyncIterator<Int>>;
}

export interface DemographicsSubscriptionPayload {
  mutation: MutationType;
  node: Demographics;
  updatedFields: String[];
  previousValues: DemographicsPreviousValues;
}

export interface DemographicsSubscriptionPayloadPromise
  extends Promise<DemographicsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DemographicsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DemographicsPreviousValuesPromise>() => T;
}

export interface DemographicsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DemographicsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DemographicsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DemographicsPreviousValuesSubscription>() => T;
}

export interface DemographicsPreviousValues {
  numStudents?: Int;
  numUndergraduates?: Int;
  numGraduates?: Int;
}

export interface DemographicsPreviousValuesPromise
  extends Promise<DemographicsPreviousValues>,
    Fragmentable {
  numStudents: () => Promise<Int>;
  numUndergraduates: () => Promise<Int>;
  numGraduates: () => Promise<Int>;
}

export interface DemographicsPreviousValuesSubscription
  extends Promise<AsyncIterator<DemographicsPreviousValues>>,
    Fragmentable {
  numStudents: () => Promise<AsyncIterator<Int>>;
  numUndergraduates: () => Promise<AsyncIterator<Int>>;
  numGraduates: () => Promise<AsyncIterator<Int>>;
}

export interface GeographySubscriptionPayload {
  mutation: MutationType;
  node: Geography;
  updatedFields: String[];
}

export interface GeographySubscriptionPayloadPromise
  extends Promise<GeographySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GeographyPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface GeographySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GeographySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GeographySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  latittude?: Float;
  longitude?: Float;
  state?: String;
  city?: String;
  zip?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  latittude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  state: () => Promise<String>;
  city: () => Promise<String>;
  zip: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  latittude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  state: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface OverviewSubscriptionPayload {
  mutation: MutationType;
  node: Overview;
  updatedFields: String[];
  previousValues: OverviewPreviousValues;
}

export interface OverviewSubscriptionPayloadPromise
  extends Promise<OverviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OverviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OverviewPreviousValuesPromise>() => T;
}

export interface OverviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OverviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OverviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OverviewPreviousValuesSubscription>() => T;
}

export interface OverviewPreviousValues {
  name: String;
  description?: String;
  url?: String;
  menOnly?: Boolean;
  womenOnly?: Boolean;
  operating?: Boolean;
  onlineOnly?: Boolean;
  deadline?: DateTimeOutput;
  system?: System;
}

export interface OverviewPreviousValuesPromise
  extends Promise<OverviewPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  menOnly: () => Promise<Boolean>;
  womenOnly: () => Promise<Boolean>;
  operating: () => Promise<Boolean>;
  onlineOnly: () => Promise<Boolean>;
  deadline: () => Promise<DateTimeOutput>;
  system: () => Promise<System>;
}

export interface OverviewPreviousValuesSubscription
  extends Promise<AsyncIterator<OverviewPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  menOnly: () => Promise<AsyncIterator<Boolean>>;
  womenOnly: () => Promise<AsyncIterator<Boolean>>;
  operating: () => Promise<AsyncIterator<Boolean>>;
  onlineOnly: () => Promise<AsyncIterator<Boolean>>;
  deadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  system: () => Promise<AsyncIterator<System>>;
}

export interface RankingSubscriptionPayload {
  mutation: MutationType;
  node: Ranking;
  updatedFields: String[];
  previousValues: RankingPreviousValues;
}

export interface RankingSubscriptionPayloadPromise
  extends Promise<RankingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RankingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RankingPreviousValuesPromise>() => T;
}

export interface RankingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RankingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RankingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RankingPreviousValuesSubscription>() => T;
}

export interface RankingPreviousValues {
  name?: String;
  rank?: Int;
}

export interface RankingPreviousValuesPromise
  extends Promise<RankingPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  rank: () => Promise<Int>;
}

export interface RankingPreviousValuesSubscription
  extends Promise<AsyncIterator<RankingPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
}

export interface SatScoresSubscriptionPayload {
  mutation: MutationType;
  node: SatScores;
  updatedFields: String[];
}

export interface SatScoresSubscriptionPayloadPromise
  extends Promise<SatScoresSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SatScoresPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface SatScoresSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SatScoresSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SatScoresSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface SatScoresTemplateSubscriptionPayload {
  mutation: MutationType;
  node: SatScoresTemplate;
  updatedFields: String[];
  previousValues: SatScoresTemplatePreviousValues;
}

export interface SatScoresTemplateSubscriptionPayloadPromise
  extends Promise<SatScoresTemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SatScoresTemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SatScoresTemplatePreviousValuesPromise>() => T;
}

export interface SatScoresTemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SatScoresTemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SatScoresTemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SatScoresTemplatePreviousValuesSubscription>() => T;
}

export interface SatScoresTemplatePreviousValues {
  reading?: Int;
  writing?: Int;
  math?: Int;
}

export interface SatScoresTemplatePreviousValuesPromise
  extends Promise<SatScoresTemplatePreviousValues>,
    Fragmentable {
  reading: () => Promise<Int>;
  writing: () => Promise<Int>;
  math: () => Promise<Int>;
}

export interface SatScoresTemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<SatScoresTemplatePreviousValues>>,
    Fragmentable {
  reading: () => Promise<AsyncIterator<Int>>;
  writing: () => Promise<AsyncIterator<Int>>;
  math: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolDetailsItemSubscriptionPayload {
  mutation: MutationType;
  node: SchoolDetailsItem;
  updatedFields: String[];
  previousValues: SchoolDetailsItemPreviousValues;
}

export interface SchoolDetailsItemSubscriptionPayloadPromise
  extends Promise<SchoolDetailsItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolDetailsItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolDetailsItemPreviousValuesPromise>() => T;
}

export interface SchoolDetailsItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolDetailsItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolDetailsItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolDetailsItemPreviousValuesSubscription>() => T;
}

export interface SchoolDetailsItemPreviousValues {
  id: ID_Output;
  images: String[];
}

export interface SchoolDetailsItemPreviousValuesPromise
  extends Promise<SchoolDetailsItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  images: () => Promise<String[]>;
}

export interface SchoolDetailsItemPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolDetailsItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  images: () => Promise<AsyncIterator<String[]>>;
}

export interface SchoolListItemSubscriptionPayload {
  mutation: MutationType;
  node: SchoolListItem;
  updatedFields: String[];
  previousValues: SchoolListItemPreviousValues;
}

export interface SchoolListItemSubscriptionPayloadPromise
  extends Promise<SchoolListItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolListItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolListItemPreviousValuesPromise>() => T;
}

export interface SchoolListItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolListItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolListItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolListItemPreviousValuesSubscription>() => T;
}

export interface SchoolListItemPreviousValues {
  id: ID_Output;
  name?: String;
  thumbnail?: String;
  acceptanceRate?: Float;
  toeflMinScore?: Int;
  regularDeadline?: DateTimeOutput;
}

export interface SchoolListItemPreviousValuesPromise
  extends Promise<SchoolListItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  thumbnail: () => Promise<String>;
  acceptanceRate: () => Promise<Float>;
  toeflMinScore: () => Promise<Int>;
  regularDeadline: () => Promise<DateTimeOutput>;
}

export interface SchoolListItemPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolListItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  acceptanceRate: () => Promise<AsyncIterator<Float>>;
  toeflMinScore: () => Promise<AsyncIterator<Int>>;
  regularDeadline: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SchoolRecommendationSubscriptionPayload {
  mutation: MutationType;
  node: SchoolRecommendation;
  updatedFields: String[];
  previousValues: SchoolRecommendationPreviousValues;
}

export interface SchoolRecommendationSubscriptionPayloadPromise
  extends Promise<SchoolRecommendationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolRecommendationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolRecommendationPreviousValuesPromise>() => T;
}

export interface SchoolRecommendationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolRecommendationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolRecommendationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolRecommendationPreviousValuesSubscription>() => T;
}

export interface SchoolRecommendationPreviousValues {
  names: String[];
}

export interface SchoolRecommendationPreviousValuesPromise
  extends Promise<SchoolRecommendationPreviousValues>,
    Fragmentable {
  names: () => Promise<String[]>;
}

export interface SchoolRecommendationPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolRecommendationPreviousValues>>,
    Fragmentable {
  names: () => Promise<AsyncIterator<String[]>>;
}

export interface SchoolSuggestionSubscriptionPayload {
  mutation: MutationType;
  node: SchoolSuggestion;
  updatedFields: String[];
  previousValues: SchoolSuggestionPreviousValues;
}

export interface SchoolSuggestionSubscriptionPayloadPromise
  extends Promise<SchoolSuggestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolSuggestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolSuggestionPreviousValuesPromise>() => T;
}

export interface SchoolSuggestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolSuggestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolSuggestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolSuggestionPreviousValuesSubscription>() => T;
}

export interface SchoolSuggestionPreviousValues {
  names: String[];
}

export interface SchoolSuggestionPreviousValuesPromise
  extends Promise<SchoolSuggestionPreviousValues>,
    Fragmentable {
  names: () => Promise<String[]>;
}

export interface SchoolSuggestionPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolSuggestionPreviousValues>>,
    Fragmentable {
  names: () => Promise<AsyncIterator<String[]>>;
}

export interface collegeSubscriptionPayload {
  mutation: MutationType;
  node: college;
  updatedFields: String[];
  previousValues: collegePreviousValues;
}

export interface collegeSubscriptionPayloadPromise
  extends Promise<collegeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = collegePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = collegePreviousValuesPromise>() => T;
}

export interface collegeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<collegeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = collegeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = collegePreviousValuesSubscription>() => T;
}

export interface collegePreviousValues {
  name?: String;
  rank?: Int;
}

export interface collegePreviousValuesPromise
  extends Promise<collegePreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  rank: () => Promise<Int>;
}

export interface collegePreviousValuesSubscription
  extends Promise<AsyncIterator<collegePreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
}

export interface majorSubscriptionPayload {
  mutation: MutationType;
  node: major;
  updatedFields: String[];
  previousValues: majorPreviousValues;
}

export interface majorSubscriptionPayloadPromise
  extends Promise<majorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = majorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = majorPreviousValuesPromise>() => T;
}

export interface majorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<majorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = majorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = majorPreviousValuesSubscription>() => T;
}

export interface majorPreviousValues {
  name?: String;
  rank?: Int;
}

export interface majorPreviousValuesPromise
  extends Promise<majorPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  rank: () => Promise<Int>;
}

export interface majorPreviousValuesSubscription
  extends Promise<AsyncIterator<majorPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Academics",
    embedded: false
  },
  {
    name: "ActScores",
    embedded: false
  },
  {
    name: "ActScoresTemplate",
    embedded: false
  },
  {
    name: "Admission",
    embedded: false
  },
  {
    name: "Badge",
    embedded: false
  },
  {
    name: "Cost",
    embedded: false
  },
  {
    name: "Demographics",
    embedded: false
  },
  {
    name: "Geography",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Overview",
    embedded: false
  },
  {
    name: "Ranking",
    embedded: false
  },
  {
    name: "SatScores",
    embedded: false
  },
  {
    name: "SatScoresTemplate",
    embedded: false
  },
  {
    name: "SchoolDetailsItem",
    embedded: false
  },
  {
    name: "SchoolListItem",
    embedded: false
  },
  {
    name: "SchoolRecommendation",
    embedded: false
  },
  {
    name: "SchoolSuggestion",
    embedded: false
  },
  {
    name: "SortByColumn",
    embedded: false
  },
  {
    name: "System",
    embedded: false
  },
  {
    name: "college",
    embedded: false
  },
  {
    name: "major",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
